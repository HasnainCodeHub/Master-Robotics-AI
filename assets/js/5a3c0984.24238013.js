"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[3582],{8101(n,r,e){e.r(r),e.d(r,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>s,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"module-3/chapter-4-simulated-actuators","title":"Chapter 4: Simulated Actuators","description":"Chapter Goal","source":"@site/docs/module-3/chapter-4-simulated-actuators.md","sourceDirName":"module-3","slug":"/module-3/chapter-4-simulated-actuators","permalink":"/Master-Robotics-AI/textbook/module-3/chapter-4-simulated-actuators","draft":false,"unlisted":false,"editUrl":"https://github.com/HasnainCodeHub/Master-Robotics-AI/tree/main/docs/docs/module-3/chapter-4-simulated-actuators.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"id":"chapter-4-simulated-actuators","title":"Chapter 4: Simulated Actuators","sidebar_label":"4. Simulated Actuators","sidebar_position":5},"sidebar":"textbookSidebar","previous":{"title":"3. Simulated Sensors","permalink":"/Master-Robotics-AI/textbook/module-3/chapter-3-simulated-sensors"},"next":{"title":"5. Unity Integration","permalink":"/Master-Robotics-AI/textbook/module-3/chapter-5-unity-integration"}}');var i=e(4848),o=e(8453);const s={id:"chapter-4-simulated-actuators",title:"Chapter 4: Simulated Actuators",sidebar_label:"4. Simulated Actuators",sidebar_position:5},a="Chapter 4: Simulated Actuators and Control Interfaces",l={},c=[{value:"Chapter Goal",id:"chapter-goal",level:2},{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Why Actuator Modeling Matters",id:"why-actuator-modeling-matters",level:2},{value:"Spawning Robots from URDF",id:"spawn-urdf",level:2},{value:"URDF to Gazebo",id:"urdf-to-gazebo",level:3},{value:"Spawning in Gazebo",id:"spawning-in-gazebo",level:3},{value:"Verifying Physics Properties",id:"verifying-physics-properties",level:3},{value:"Joint Controllers",id:"joint-controllers",level:2},{value:"Control Modes",id:"control-modes",level:3},{value:"ros2_control Configuration",id:"ros2_control-configuration",level:3},{value:"PID Tuning Methodology",id:"pid-tuning-methodology",level:3},{value:"Tuning Process",id:"tuning-process",level:3},{value:"Modeling Actuator Dynamics",id:"actuator-dynamics",level:2},{value:"Time Constant (Delay)",id:"time-constant-delay",level:3},{value:"Effort Saturation",id:"effort-saturation",level:3},{value:"Velocity Saturation",id:"velocity-saturation",level:3},{value:"Friction and Damping",id:"friction",level:2},{value:"Joint Dynamics in URDF",id:"joint-dynamics-in-urdf",level:3},{value:"Friction Types",id:"friction-types",level:3},{value:"Configuring Realistic Friction",id:"configuring-realistic-friction",level:3},{value:"Differential Drive Controller",id:"diff-drive",level:2},{value:"URDF Configuration",id:"urdf-configuration",level:3},{value:"Controller Configuration",id:"controller-configuration",level:3},{value:"Teleoperation Test",id:"teleoperation-test",level:3},{value:"Joint Trajectory Controller",id:"trajectory-controller",level:2},{value:"Configuration",id:"configuration",level:3},{value:"Sending Trajectory Commands",id:"sending-trajectory-commands",level:3},{value:"Complete Mobile Manipulator Example",id:"complete-example",level:2},{value:"Summary",id:"summary",level:2},{value:"Reality Gap Callout",id:"reality-gap-callout",level:2},{value:"Self-Assessment Questions",id:"self-assessment-questions",level:2},{value:"What&#39;s Next",id:"whats-next",level:2}];function d(n){const r={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,o.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(r.header,{children:(0,i.jsx)(r.h1,{id:"chapter-4-simulated-actuators-and-control-interfaces",children:"Chapter 4: Simulated Actuators and Control Interfaces"})}),"\n",(0,i.jsx)(r.h2,{id:"chapter-goal",children:"Chapter Goal"}),"\n",(0,i.jsxs)(r.p,{children:["By the end of this chapter, you will be able to ",(0,i.jsx)(r.strong,{children:"configure simulated actuators with realistic response characteristics including delay, saturation, friction, and backlash"}),", and implement control interfaces through ROS 2."]}),"\n",(0,i.jsx)(r.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,i.jsx)(r.p,{children:"After completing this chapter, you will be able to:"}),"\n",(0,i.jsxs)(r.table,{children:[(0,i.jsx)(r.thead,{children:(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.th,{children:"ID"}),(0,i.jsx)(r.th,{children:"Objective"})]})}),(0,i.jsxs)(r.tbody,{children:[(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"4.1"}),(0,i.jsx)(r.td,{children:"Spawn a robot from URDF in Gazebo with physics properties correctly configured"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"4.2"}),(0,i.jsx)(r.td,{children:"Configure joint controllers (position, velocity, effort) with appropriate PID gains"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"4.3"}),(0,i.jsx)(r.td,{children:"Add actuator delay simulating motor time constants"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"4.4"}),(0,i.jsx)(r.td,{children:"Configure joint friction and damping that affects motion under load"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"4.5"}),(0,i.jsx)(r.td,{children:"Implement differential drive controller for mobile robots"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"4.6"}),(0,i.jsx)(r.td,{children:"Implement joint trajectory controller for manipulators"})]})]})]}),"\n",(0,i.jsx)(r.hr,{}),"\n",(0,i.jsx)(r.h2,{id:"why-actuator-modeling-matters",children:"Why Actuator Modeling Matters"}),"\n",(0,i.jsx)(r.p,{children:"Consider this scenario: You tune a PID controller in simulation and achieve perfect tracking. On real hardware, the arm oscillates and overshoots."}),"\n",(0,i.jsx)(r.p,{children:"What happened? The simulated actuator was too ideal:"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"No delay"}),": Real motors have electrical and mechanical time constants"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"No saturation"}),": Real motors have torque/speed limits"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"No friction"}),": Real joints have static and dynamic friction"]}),"\n"]}),"\n",(0,i.jsx)(r.p,{children:"This chapter makes simulated actuators behave more like real hardware."}),"\n",(0,i.jsx)(r.hr,{}),"\n",(0,i.jsx)(r.h2,{id:"spawn-urdf",children:"Spawning Robots from URDF"}),"\n",(0,i.jsx)(r.h3,{id:"urdf-to-gazebo",children:"URDF to Gazebo"}),"\n",(0,i.jsx)(r.p,{children:"Your URDF from Module 2 needs additional elements for Gazebo:"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-xml",children:'<?xml version="1.0"?>\r\n<robot name="my_robot">\r\n  \x3c!-- Standard URDF elements --\x3e\r\n  <link name="base_link">\r\n    <visual>...</visual>\r\n    <collision>...</collision>\r\n    <inertial>\r\n      <mass value="10.0"/>\r\n      <inertia ixx="0.1" ixy="0" ixz="0" iyy="0.1" iyz="0" izz="0.1"/>\r\n    </inertial>\r\n  </link>\r\n\r\n  \x3c!-- Gazebo-specific elements --\x3e\r\n  <gazebo reference="base_link">\r\n    <material>Gazebo/Blue</material>\r\n    <mu1>0.8</mu1>\r\n    <mu2>0.8</mu2>\r\n  </gazebo>\r\n\r\n  \x3c!-- ros2_control for joint control --\x3e\r\n  <ros2_control name="GazeboSimSystem" type="system">\r\n    <hardware>\r\n      <plugin>gz_ros2_control/GazeboSimSystem</plugin>\r\n    </hardware>\r\n    <joint name="joint1">\r\n      <command_interface name="position"/>\r\n      <state_interface name="position"/>\r\n      <state_interface name="velocity"/>\r\n    </joint>\r\n  </ros2_control>\r\n</robot>\n'})}),"\n",(0,i.jsx)(r.h3,{id:"spawning-in-gazebo",children:"Spawning in Gazebo"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-python",children:"# launch/spawn_robot.launch.py\r\nfrom launch import LaunchDescription\r\nfrom launch_ros.actions import Node\r\nfrom launch.actions import ExecuteProcess\r\nimport os\r\n\r\ndef generate_launch_description():\r\n    urdf_path = os.path.join(\r\n        os.getenv('HOME'),\r\n        'ros2_ws/src/my_robot/urdf/robot.urdf'\r\n    )\r\n\r\n    return LaunchDescription([\r\n        # Spawn robot in Gazebo\r\n        Node(\r\n            package='ros_gz_sim',\r\n            executable='create',\r\n            arguments=[\r\n                '-file', urdf_path,\r\n                '-name', 'my_robot',\r\n                '-x', '0',\r\n                '-y', '0',\r\n                '-z', '0.1'\r\n            ],\r\n            output='screen'\r\n        ),\r\n    ])\n"})}),"\n",(0,i.jsx)(r.h3,{id:"verifying-physics-properties",children:"Verifying Physics Properties"}),"\n",(0,i.jsx)(r.p,{children:"After spawning, verify in Gazebo GUI:"}),"\n",(0,i.jsxs)(r.ol,{children:["\n",(0,i.jsx)(r.li,{children:"Select model \u2192 Right-click \u2192 View \u2192 Inertia"}),"\n",(0,i.jsx)(r.li,{children:"Check that inertia ellipsoids match expected mass distribution"}),"\n",(0,i.jsx)(r.li,{children:"Verify collision geometry covers visual geometry"}),"\n"]}),"\n",(0,i.jsx)(r.hr,{}),"\n",(0,i.jsx)(r.h2,{id:"joint-controllers",children:"Joint Controllers"}),"\n",(0,i.jsx)(r.h3,{id:"control-modes",children:"Control Modes"}),"\n",(0,i.jsxs)(r.table,{children:[(0,i.jsx)(r.thead,{children:(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.th,{children:"Mode"}),(0,i.jsx)(r.th,{children:"Command"}),(0,i.jsx)(r.th,{children:"Use Case"})]})}),(0,i.jsxs)(r.tbody,{children:[(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"Position"}),(0,i.jsx)(r.td,{children:"Target angle (rad)"}),(0,i.jsx)(r.td,{children:"Precise positioning"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"Velocity"}),(0,i.jsx)(r.td,{children:"Target speed (rad/s)"}),(0,i.jsx)(r.td,{children:"Continuous rotation"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"Effort"}),(0,i.jsx)(r.td,{children:"Torque (Nm)"}),(0,i.jsx)(r.td,{children:"Direct force control"})]})]})]}),"\n",(0,i.jsx)(r.h3,{id:"ros2_control-configuration",children:"ros2_control Configuration"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-yaml",children:"# config/controllers.yaml\r\ncontroller_manager:\r\n  ros__parameters:\r\n    update_rate: 100  # Hz\r\n\r\n    joint_state_broadcaster:\r\n      type: joint_state_broadcaster/JointStateBroadcaster\r\n\r\n    arm_controller:\r\n      type: joint_trajectory_controller/JointTrajectoryController\r\n\r\narm_controller:\r\n  ros__parameters:\r\n    joints:\r\n      - shoulder_joint\r\n      - elbow_joint\r\n      - wrist_joint\r\n\r\n    command_interfaces:\r\n      - position\r\n\r\n    state_interfaces:\r\n      - position\r\n      - velocity\r\n\r\n    # PID gains (critical for realistic behavior)\r\n    gains:\r\n      shoulder_joint:\r\n        p: 100.0\r\n        i: 0.0\r\n        d: 10.0\r\n      elbow_joint:\r\n        p: 80.0\r\n        i: 0.0\r\n        d: 8.0\r\n      wrist_joint:\r\n        p: 50.0\r\n        i: 0.0\r\n        d: 5.0\n"})}),"\n",(0,i.jsx)(r.h3,{id:"pid-tuning-methodology",children:"PID Tuning Methodology"}),"\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.strong,{children:"Physical Grounding"}),": PID gains depend on joint inertia from Module 1:"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{children:"Approximate starting gains:\r\n  P \u2248 inertia \xd7 (desired_bandwidth)\xb2\r\n  D \u2248 2 \xd7 sqrt(P \xd7 inertia) \xd7 damping_ratio\r\n  I = 0 initially (add if steady-state error)\r\n\r\nExample for joint with inertia = 0.1 kg\xb7m\xb2, bandwidth = 10 rad/s:\r\n  P = 0.1 \xd7 10\xb2 = 10\r\n  D = 2 \xd7 sqrt(10 \xd7 0.1) \xd7 0.7 = 1.4\n"})}),"\n",(0,i.jsx)(r.h3,{id:"tuning-process",children:"Tuning Process"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-bash",children:"# 1. Start with low gains\r\nP=10, I=0, D=0\r\n\r\n# 2. Increase P until oscillation begins\r\n# 3. Back off P by 50%\r\n# 4. Add D to reduce overshoot\r\n# 5. Add small I if steady-state error exists\r\n\r\n# Monitor response\r\nros2 topic echo /joint_states\n"})}),"\n",(0,i.jsx)(r.hr,{}),"\n",(0,i.jsx)(r.h2,{id:"actuator-dynamics",children:"Modeling Actuator Dynamics"}),"\n",(0,i.jsx)(r.h3,{id:"time-constant-delay",children:"Time Constant (Delay)"}),"\n",(0,i.jsx)(r.p,{children:"Real actuators don't respond instantly. Model the lag:"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-xml",children:'\x3c!-- In URDF gazebo extension --\x3e\r\n<transmission name="shoulder_transmission">\r\n  <type>transmission_interface/SimpleTransmission</type>\r\n  <joint name="shoulder_joint">\r\n    <hardwareInterface>hardware_interface/EffortJointInterface</hardwareInterface>\r\n  </joint>\r\n  <actuator name="shoulder_motor">\r\n    <mechanicalReduction>100</mechanicalReduction>\r\n  </actuator>\r\n</transmission>\r\n\r\n\x3c!-- In Gazebo plugin configuration --\x3e\r\n<plugin name="gz_ros2_control" filename="libgz_ros2_control-system.so">\r\n  <parameters>\r\n    <joint name="shoulder_joint">\r\n      <motor_model>\r\n        <time_constant>0.05</time_constant>  \x3c!-- 50ms response --\x3e\r\n      </motor_model>\r\n    </joint>\r\n  </parameters>\r\n</plugin>\n'})}),"\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.strong,{children:"Physical Grounding"}),": Motor time constant from Module 1:"]}),"\n",(0,i.jsxs)(r.table,{children:[(0,i.jsx)(r.thead,{children:(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.th,{children:"Motor Type"}),(0,i.jsx)(r.th,{children:"Typical Time Constant"})]})}),(0,i.jsxs)(r.tbody,{children:[(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"Small servo"}),(0,i.jsx)(r.td,{children:"20-50 ms"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"Industrial servo"}),(0,i.jsx)(r.td,{children:"5-20 ms"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"Geared DC motor"}),(0,i.jsx)(r.td,{children:"50-200 ms"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"Stepper"}),(0,i.jsx)(r.td,{children:"Near-instant (but discrete)"})]})]})]}),"\n",(0,i.jsx)(r.h3,{id:"effort-saturation",children:"Effort Saturation"}),"\n",(0,i.jsx)(r.p,{children:"Real motors have torque limits:"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-yaml",children:"# In ros2_control config\r\narm_controller:\r\n  ros__parameters:\r\n    joints:\r\n      - shoulder_joint\r\n\r\n    # Effort limits\r\n    constraints:\r\n      shoulder_joint:\r\n        min_effort: -10.0  # Nm\r\n        max_effort: 10.0   # Nm\n"})}),"\n",(0,i.jsx)(r.p,{children:"In URDF:"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-xml",children:'<joint name="shoulder_joint" type="revolute">\r\n  <limit\r\n    lower="-3.14"\r\n    upper="3.14"\r\n    velocity="2.0"      \x3c!-- rad/s max --\x3e\r\n    effort="10.0"       \x3c!-- Nm max torque --\x3e\r\n  />\r\n</joint>\n'})}),"\n",(0,i.jsx)(r.h3,{id:"velocity-saturation",children:"Velocity Saturation"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-yaml",children:"arm_controller:\r\n  ros__parameters:\r\n    constraints:\r\n      shoulder_joint:\r\n        max_velocity: 2.0  # rad/s\n"})}),"\n",(0,i.jsx)(r.hr,{}),"\n",(0,i.jsx)(r.h2,{id:"friction",children:"Friction and Damping"}),"\n",(0,i.jsx)(r.h3,{id:"joint-dynamics-in-urdf",children:"Joint Dynamics in URDF"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-xml",children:'<joint name="shoulder_joint" type="revolute">\r\n  <parent link="base_link"/>\r\n  <child link="upper_arm"/>\r\n  <axis xyz="0 0 1"/>\r\n  <limit lower="-3.14" upper="3.14" velocity="2.0" effort="10.0"/>\r\n\r\n  \x3c!-- Friction and damping --\x3e\r\n  <dynamics damping="0.5" friction="0.1"/>\r\n</joint>\n'})}),"\n",(0,i.jsx)(r.h3,{id:"friction-types",children:"Friction Types"}),"\n",(0,i.jsxs)(r.table,{children:[(0,i.jsx)(r.thead,{children:(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.th,{children:"Type"}),(0,i.jsx)(r.th,{children:"URDF Element"}),(0,i.jsx)(r.th,{children:"Physical Meaning"})]})}),(0,i.jsxs)(r.tbody,{children:[(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"Viscous damping"}),(0,i.jsx)(r.td,{children:(0,i.jsx)(r.code,{children:"damping"})}),(0,i.jsx)(r.td,{children:"Resistance proportional to velocity"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"Coulomb friction"}),(0,i.jsx)(r.td,{children:(0,i.jsx)(r.code,{children:"friction"})}),(0,i.jsx)(r.td,{children:"Constant resistance to motion"})]})]})]}),"\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.strong,{children:"Physical Grounding"}),":"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{children:"Joint torque required = \u03c4_command - damping \xd7 velocity - friction \xd7 sign(velocity)\n"})}),"\n",(0,i.jsx)(r.h3,{id:"configuring-realistic-friction",children:"Configuring Realistic Friction"}),"\n",(0,i.jsx)(r.p,{children:"From Module 1 actuator analysis:"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-xml",children:'\x3c!-- High-quality ball bearing joint --\x3e\r\n<dynamics damping="0.1" friction="0.01"/>\r\n\r\n\x3c!-- Gearbox with moderate friction --\x3e\r\n<dynamics damping="0.5" friction="0.2"/>\r\n\r\n\x3c!-- Worn or low-quality joint --\x3e\r\n<dynamics damping="1.0" friction="0.5"/>\n'})}),"\n",(0,i.jsx)(r.hr,{}),"\n",(0,i.jsx)(r.h2,{id:"diff-drive",children:"Differential Drive Controller"}),"\n",(0,i.jsx)(r.p,{children:"For mobile robots with two drive wheels:"}),"\n",(0,i.jsx)(r.h3,{id:"urdf-configuration",children:"URDF Configuration"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-xml",children:'<ros2_control name="DiffDriveSystem" type="system">\r\n  <hardware>\r\n    <plugin>gz_ros2_control/GazeboSimSystem</plugin>\r\n  </hardware>\r\n  <joint name="left_wheel_joint">\r\n    <command_interface name="velocity"/>\r\n    <state_interface name="position"/>\r\n    <state_interface name="velocity"/>\r\n  </joint>\r\n  <joint name="right_wheel_joint">\r\n    <command_interface name="velocity"/>\r\n    <state_interface name="position"/>\r\n    <state_interface name="velocity"/>\r\n  </joint>\r\n</ros2_control>\n'})}),"\n",(0,i.jsx)(r.h3,{id:"controller-configuration",children:"Controller Configuration"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-yaml",children:'# config/diff_drive.yaml\r\ncontroller_manager:\r\n  ros__parameters:\r\n    update_rate: 50\r\n\r\n    diff_drive_controller:\r\n      type: diff_drive_controller/DiffDriveController\r\n\r\ndiff_drive_controller:\r\n  ros__parameters:\r\n    # Wheel joints\r\n    left_wheel_names: ["left_wheel_joint"]\r\n    right_wheel_names: ["right_wheel_joint"]\r\n\r\n    # Robot geometry\r\n    wheel_separation: 0.4  # meters between wheels\r\n    wheel_radius: 0.1      # wheel radius in meters\r\n\r\n    # Velocity limits (from M1 actuator specs)\r\n    linear.x.max_velocity: 1.0      # m/s\r\n    linear.x.min_velocity: -0.5     # m/s\r\n    angular.z.max_velocity: 2.0     # rad/s\r\n    angular.z.min_velocity: -2.0    # rad/s\r\n\r\n    # Acceleration limits\r\n    linear.x.max_acceleration: 0.5  # m/s\xb2\r\n    angular.z.max_acceleration: 1.0 # rad/s\xb2\r\n\r\n    # Odometry\r\n    publish_rate: 50.0\r\n    odom_frame_id: odom\r\n    base_frame_id: base_link\r\n    pose_covariance_diagonal: [0.001, 0.001, 0.001, 0.001, 0.001, 0.01]\r\n    twist_covariance_diagonal: [0.001, 0.001, 0.001, 0.001, 0.001, 0.01]\n'})}),"\n",(0,i.jsx)(r.h3,{id:"teleoperation-test",children:"Teleoperation Test"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-bash",children:"# Terminal 1: Run simulation with controller\r\nros2 launch my_robot gazebo.launch.py\r\n\r\n# Terminal 2: Start teleop\r\nros2 run teleop_twist_keyboard teleop_twist_keyboard\r\n\r\n# Terminal 3: Monitor odometry\r\nros2 topic echo /diff_drive_controller/odom\n"})}),"\n",(0,i.jsx)(r.hr,{}),"\n",(0,i.jsx)(r.h2,{id:"trajectory-controller",children:"Joint Trajectory Controller"}),"\n",(0,i.jsx)(r.p,{children:"For robot arms requiring smooth motion:"}),"\n",(0,i.jsx)(r.h3,{id:"configuration",children:"Configuration"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-yaml",children:"arm_trajectory_controller:\r\n  ros__parameters:\r\n    joints:\r\n      - shoulder_joint\r\n      - elbow_joint\r\n      - wrist_joint\r\n\r\n    command_interfaces:\r\n      - position\r\n\r\n    state_interfaces:\r\n      - position\r\n      - velocity\r\n\r\n    # Trajectory constraints\r\n    constraints:\r\n      stopped_velocity_tolerance: 0.01\r\n      goal_time: 0.0  # 0 means no time constraint\r\n\r\n      shoulder_joint:\r\n        trajectory: 0.1  # position tolerance during motion\r\n        goal: 0.01       # position tolerance at goal\r\n\r\n      elbow_joint:\r\n        trajectory: 0.1\r\n        goal: 0.01\r\n\r\n      wrist_joint:\r\n        trajectory: 0.05\r\n        goal: 0.005\n"})}),"\n",(0,i.jsx)(r.h3,{id:"sending-trajectory-commands",children:"Sending Trajectory Commands"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-python",children:"#!/usr/bin/env python3\r\n\"\"\"Send joint trajectory to arm controller.\"\"\"\r\n\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom rclpy.action import ActionClient\r\nfrom control_msgs.action import FollowJointTrajectory\r\nfrom trajectory_msgs.msg import JointTrajectoryPoint\r\nfrom builtin_interfaces.msg import Duration\r\n\r\n\r\nclass TrajectoryClient(Node):\r\n    def __init__(self):\r\n        super().__init__('trajectory_client')\r\n\r\n        self._action_client = ActionClient(\r\n            self,\r\n            FollowJointTrajectory,\r\n            '/arm_trajectory_controller/follow_joint_trajectory'\r\n        )\r\n\r\n    def send_trajectory(self):\r\n        goal = FollowJointTrajectory.Goal()\r\n\r\n        goal.trajectory.joint_names = [\r\n            'shoulder_joint',\r\n            'elbow_joint',\r\n            'wrist_joint'\r\n        ]\r\n\r\n        # Point 1: Home position\r\n        point1 = JointTrajectoryPoint()\r\n        point1.positions = [0.0, 0.0, 0.0]\r\n        point1.time_from_start = Duration(sec=0, nanosec=0)\r\n\r\n        # Point 2: Intermediate\r\n        point2 = JointTrajectoryPoint()\r\n        point2.positions = [0.5, 0.3, 0.0]\r\n        point2.time_from_start = Duration(sec=2, nanosec=0)\r\n\r\n        # Point 3: Goal\r\n        point3 = JointTrajectoryPoint()\r\n        point3.positions = [1.0, 0.6, 0.2]\r\n        point3.time_from_start = Duration(sec=4, nanosec=0)\r\n\r\n        goal.trajectory.points = [point1, point2, point3]\r\n\r\n        self._action_client.wait_for_server()\r\n        future = self._action_client.send_goal_async(goal)\r\n\r\n        return future\r\n\r\n\r\ndef main():\r\n    rclpy.init()\r\n    client = TrajectoryClient()\r\n    future = client.send_trajectory()\r\n    rclpy.spin_until_future_complete(client, future)\r\n    client.destroy_node()\r\n    rclpy.shutdown()\r\n\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,i.jsx)(r.hr,{}),"\n",(0,i.jsx)(r.h2,{id:"complete-example",children:"Complete Mobile Manipulator Example"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-yaml",children:'# config/mobile_manipulator.yaml\r\ncontroller_manager:\r\n  ros__parameters:\r\n    update_rate: 100\r\n\r\n    joint_state_broadcaster:\r\n      type: joint_state_broadcaster/JointStateBroadcaster\r\n\r\n    diff_drive_controller:\r\n      type: diff_drive_controller/DiffDriveController\r\n\r\n    arm_controller:\r\n      type: joint_trajectory_controller/JointTrajectoryController\r\n\r\n    gripper_controller:\r\n      type: position_controllers/GripperActionController\r\n\r\n# Diff drive for base\r\ndiff_drive_controller:\r\n  ros__parameters:\r\n    left_wheel_names: ["left_wheel_joint"]\r\n    right_wheel_names: ["right_wheel_joint"]\r\n    wheel_separation: 0.5\r\n    wheel_radius: 0.1\r\n    linear.x.max_velocity: 1.0\r\n    angular.z.max_velocity: 2.0\r\n\r\n# Trajectory controller for arm\r\narm_controller:\r\n  ros__parameters:\r\n    joints:\r\n      - shoulder_pan_joint\r\n      - shoulder_lift_joint\r\n      - elbow_joint\r\n      - wrist_1_joint\r\n      - wrist_2_joint\r\n      - wrist_3_joint\r\n    command_interfaces: [position]\r\n    state_interfaces: [position, velocity]\r\n\r\n# Gripper controller\r\ngripper_controller:\r\n  ros__parameters:\r\n    joint: gripper_joint\r\n    max_effort: 50.0\r\n    stall_velocity_threshold: 0.001\n'})}),"\n",(0,i.jsx)(r.hr,{}),"\n",(0,i.jsx)(r.h2,{id:"summary",children:"Summary"}),"\n",(0,i.jsx)(r.p,{children:"This chapter covered configuring simulated actuators:"}),"\n",(0,i.jsxs)(r.ol,{children:["\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.strong,{children:"URDF spawning"})," requires inertial properties and Gazebo-specific extensions."]}),"\n"]}),"\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.strong,{children:"Joint controllers"})," (position, velocity, effort) need PID tuning based on joint inertia."]}),"\n"]}),"\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.strong,{children:"Actuator delay"})," models motor time constants\u2014critical for realistic control behavior."]}),"\n"]}),"\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.strong,{children:"Friction and damping"})," affect motion under load; configure from actuator specifications."]}),"\n"]}),"\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.strong,{children:"Diff drive controller"})," translates cmd_vel to wheel velocities for mobile robots."]}),"\n"]}),"\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.strong,{children:"Trajectory controller"})," enables smooth multi-joint motion for manipulators."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(r.hr,{}),"\n",(0,i.jsx)(r.h2,{id:"reality-gap-callout",children:"Reality Gap Callout"}),"\n",(0,i.jsx)(r.p,{children:"Simulated actuators differ from real actuators:"}),"\n",(0,i.jsxs)(r.table,{children:[(0,i.jsx)(r.thead,{children:(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.th,{children:"Aspect"}),(0,i.jsx)(r.th,{children:"Simulation"}),(0,i.jsx)(r.th,{children:"Reality"})]})}),(0,i.jsxs)(r.tbody,{children:[(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"Electrical dynamics"}),(0,i.jsx)(r.td,{children:"Ignored"}),(0,i.jsx)(r.td,{children:"Motor inductance affects response"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"Gear backlash"}),(0,i.jsx)(r.td,{children:"Not modeled"}),(0,i.jsx)(r.td,{children:"Causes position uncertainty"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"Thermal effects"}),(0,i.jsx)(r.td,{children:"Ignored"}),(0,i.jsx)(r.td,{children:"Motors derate when hot"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"Wear"}),(0,i.jsx)(r.td,{children:"Static"}),(0,i.jsx)(r.td,{children:"Parameters change over time"})]})]})]}),"\n",(0,i.jsx)(r.hr,{}),"\n",(0,i.jsx)(r.h2,{id:"self-assessment-questions",children:"Self-Assessment Questions"}),"\n",(0,i.jsxs)(r.ol,{children:["\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.strong,{children:"PID Tuning"}),": Your simulated arm joint oscillates with P=100, I=0, D=0. What would you adjust first?"]}),"\n"]}),"\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.strong,{children:"Time Constant"}),": Your real motor has a 100ms time constant but simulation responds instantly. What parameter would you add?"]}),"\n"]}),"\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.strong,{children:"Saturation"}),": Your controller commands 20 Nm but the motor is rated for 10 Nm. What happens in simulation? On real hardware?"]}),"\n"]}),"\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.strong,{children:"Diff Drive"}),": Your robot curves left when commanded to go straight. What calibration parameter is likely wrong?"]}),"\n"]}),"\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.strong,{children:"Trajectory Execution"}),': A trajectory succeeds in simulation but fails on hardware with "goal tolerance violated". What might cause this?']}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(r.hr,{}),"\n",(0,i.jsx)(r.h2,{id:"whats-next",children:"What's Next"}),"\n",(0,i.jsxs)(r.p,{children:["In ",(0,i.jsx)(r.a,{href:"/module-3/chapter-5-unity-integration",children:"Chapter 5: Unity Integration"}),", you'll learn to use Unity as an alternative simulation platform with ROS 2 integration\u2014useful for photorealistic rendering and perception training."]})]})}function h(n={}){const{wrapper:r}={...(0,o.R)(),...n.components};return r?(0,i.jsx)(r,{...n,children:(0,i.jsx)(d,{...n})}):d(n)}},8453(n,r,e){e.d(r,{R:()=>s,x:()=>a});var t=e(6540);const i={},o=t.createContext(i);function s(n){const r=t.useContext(o);return t.useMemo(function(){return"function"==typeof n?n(r):{...r,...n}},[r,n])}function a(n){let r;return r=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:s(n.components),t.createElement(o.Provider,{value:r},n.children)}}}]);