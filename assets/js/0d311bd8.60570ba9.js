"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[5010],{6693(e,n,r){r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>a,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"module-5/chapter-5-safety-constraints","title":"Chapter 5: Safety Constraints","description":"Chapter Goal","source":"@site/docs/module-5/chapter-5-safety-constraints.md","sourceDirName":"module-5","slug":"/module-5/chapter-5-safety-constraints","permalink":"/Master-Robotics-AI/textbook/module-5/chapter-5-safety-constraints","draft":false,"unlisted":false,"editUrl":"https://github.com/HasnainCodeHub/Master-Robotics-AI/tree/main/docs/docs/module-5/chapter-5-safety-constraints.md","tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"id":"chapter-5-safety-constraints","title":"Chapter 5: Safety Constraints","sidebar_label":"5. Safety Constraints","sidebar_position":6},"sidebar":"textbookSidebar","previous":{"title":"4. Vision-Language Models","permalink":"/Master-Robotics-AI/textbook/module-5/chapter-4-vision-language-models"},"next":{"title":"6. Failure Handling","permalink":"/Master-Robotics-AI/textbook/module-5/chapter-6-failure-handling"}}');var i=r(4848),s=r(8453);const a={id:"chapter-5-safety-constraints",title:"Chapter 5: Safety Constraints",sidebar_label:"5. Safety Constraints",sidebar_position:6},o="Chapter 5: Safety Constraints for AI-Generated Commands",l={},c=[{value:"Chapter Goal",id:"chapter-goal",level:2},{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Safety Philosophy",id:"philosophy",level:2},{value:"The Safety Override Principle",id:"the-safety-override-principle",level:3},{value:"Defense in Depth",id:"defense-in-depth",level:3},{value:"Safety Constraint Architecture",id:"architecture",level:2},{value:"SafetyFilter Base Class",id:"safetyfilter-base-class",level:3},{value:"Safety Filter Node",id:"safety-filter-node",level:3},{value:"Workspace Boundary Checking",id:"workspace",level:2},{value:"Cartesian Workspace Limits",id:"cartesian-workspace-limits",level:3},{value:"Joint Limit Checking",id:"joint-limit-checking",level:3},{value:"Velocity and Acceleration Limits",id:"velocity",level:2},{value:"Motion Limit Checking",id:"motion-limit-checking",level:3},{value:"Collision Checking",id:"collision",level:2},{value:"Perception-Based Collision Avoidance",id:"perception-based-collision-avoidance",level:3},{value:"Force Limits and Contact Safety",id:"force",level:2},{value:"Force-Limited Operations",id:"force-limited-operations",level:3},{value:"Payload Checking",id:"payload-checking",level:3},{value:"Safety Rejection Responses",id:"responses",level:2},{value:"Informative Rejection Messages",id:"informative-rejection-messages",level:3},{value:"Speech Synthesis Integration",id:"speech-synthesis-integration",level:3},{value:"Runtime Safety Monitoring",id:"monitoring",level:2},{value:"Continuous Safety Watch",id:"continuous-safety-watch",level:3},{value:"Summary",id:"summary",level:2},{value:"Safety Callout",id:"safety-callout",level:2},{value:"Self-Assessment Questions",id:"self-assessment-questions",level:2},{value:"What&#39;s Next",id:"whats-next",level:2}];function f(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"chapter-5-safety-constraints-for-ai-generated-commands",children:"Chapter 5: Safety Constraints for AI-Generated Commands"})}),"\n",(0,i.jsx)(n.h2,{id:"chapter-goal",children:"Chapter Goal"}),"\n",(0,i.jsxs)(n.p,{children:["By the end of this chapter, you will be able to ",(0,i.jsx)(n.strong,{children:"implement a safety constraint layer that validates AI-generated commands before execution"}),", preventing dangerous actions while providing informative feedback for recovery."]}),"\n",(0,i.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,i.jsx)(n.p,{children:"After completing this chapter, you will be able to:"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"ID"}),(0,i.jsx)(n.th,{children:"Objective"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"5.1"}),(0,i.jsx)(n.td,{children:"Design a safety constraint architecture for VLA systems"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"5.2"}),(0,i.jsx)(n.td,{children:"Implement workspace boundary checking"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"5.3"}),(0,i.jsx)(n.td,{children:"Implement velocity and acceleration limits"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"5.4"}),(0,i.jsx)(n.td,{children:"Implement collision checking with perception"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"5.5"}),(0,i.jsx)(n.td,{children:"Implement force limits and contact safety"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"5.6"}),(0,i.jsx)(n.td,{children:"Design informative safety rejection responses"})]})]})]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"philosophy",children:"Safety Philosophy"}),"\n",(0,i.jsx)(n.h3,{id:"the-safety-override-principle",children:"The Safety Override Principle"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Critical Principle"}),": Safety constraints MUST override AI outputs."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'AI says: "Move at 2 m/s"  \u2192  Safety: "Max is 0.5 m/s"  \u2192  REJECT\r\nAI says: "Path is clear"  \u2192  Safety: "Object detected"  \u2192  REJECT\r\nAI says: "Pick 50kg box"  \u2192  Safety: "Max is 5 kg"     \u2192  REJECT\n'})}),"\n",(0,i.jsxs)(n.p,{children:["The robot may fail to act, but it ",(0,i.jsx)(n.strong,{children:"must not act unsafely"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"defense-in-depth",children:"Defense in Depth"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"                    Command Input\r\n                         \u2502\r\n                         \u25bc\r\n              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n              \u2502  Layer 1: LLM Prompt \u2502  \u2190 Soft constraints in prompt\r\n              \u2502  Constraints         \u2502\r\n              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n                         \u2502\r\n                         \u25bc\r\n              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n              \u2502  Layer 2: Schema     \u2502  \u2190 Parameter validation\r\n              \u2502  Validation          \u2502\r\n              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n                         \u2502\r\n                         \u25bc\r\n              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n              \u2502  Layer 3: Safety     \u2502  \u2190 Physical constraint checking\r\n              \u2502  Filter              \u2502\r\n              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n                         \u2502\r\n                         \u25bc\r\n              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n              \u2502  Layer 4: Runtime    \u2502  \u2190 Real-time monitoring\r\n              \u2502  Monitoring          \u2502\r\n              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n                         \u2502\r\n                         \u25bc\r\n                   Safe Execution\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Each layer catches different failure modes. ",(0,i.jsx)(n.strong,{children:"Never rely on a single layer."})]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"architecture",children:"Safety Constraint Architecture"}),"\n",(0,i.jsx)(n.h3,{id:"safetyfilter-base-class",children:"SafetyFilter Base Class"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'#!/usr/bin/env python3\r\n"""Safety constraint system for VLA pipeline."""\r\n\r\nfrom abc import ABC, abstractmethod\r\nfrom dataclasses import dataclass, field\r\nfrom typing import List, Optional, Dict, Any\r\nfrom enum import Enum\r\nimport numpy as np\r\n\r\n\r\nclass SafetyLevel(Enum):\r\n    """Severity of safety violation."""\r\n    INFO = 0        # Informational, no action needed\r\n    WARNING = 1     # Concerning but allowed\r\n    VIOLATION = 2   # Not allowed, reject command\r\n    CRITICAL = 3    # Emergency, stop all motion\r\n\r\n\r\n@dataclass\r\nclass SafetyViolation:\r\n    """Details of a safety constraint violation."""\r\n    constraint_name: str\r\n    level: SafetyLevel\r\n    message: str\r\n    details: Dict[str, Any] = field(default_factory=dict)\r\n    suggested_fix: Optional[str] = None\r\n\r\n\r\n@dataclass\r\nclass SafetyCheckResult:\r\n    """Result of safety constraint checking."""\r\n    is_safe: bool\r\n    violations: List[SafetyViolation] = field(default_factory=list)\r\n\r\n    def add_violation(self, violation: SafetyViolation):\r\n        self.violations.append(violation)\r\n        if violation.level >= SafetyLevel.VIOLATION:\r\n            self.is_safe = False\r\n\r\n\r\nclass SafetyConstraint(ABC):\r\n    """Base class for safety constraints."""\r\n\r\n    @property\r\n    @abstractmethod\r\n    def name(self) -> str:\r\n        """Constraint name for logging."""\r\n        pass\r\n\r\n    @abstractmethod\r\n    def check(\r\n        self,\r\n        action: dict,\r\n        context: dict\r\n    ) -> List[SafetyViolation]:\r\n        """\r\n        Check if action violates this constraint.\r\n\r\n        Args:\r\n            action: The proposed action\r\n            context: Current robot/environment state\r\n\r\n        Returns:\r\n            List of violations (empty if safe)\r\n        """\r\n        pass\n'})}),"\n",(0,i.jsx)(n.h3,{id:"safety-filter-node",children:"Safety Filter Node"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"class SafetyFilterNode(Node):\r\n    def __init__(self):\r\n        super().__init__('safety_filter')\r\n\r\n        # Load constraints\r\n        self.constraints: List[SafetyConstraint] = [\r\n            WorkspaceBoundaryConstraint(),\r\n            VelocityLimitConstraint(),\r\n            AccelerationLimitConstraint(),\r\n            CollisionConstraint(),\r\n            ForceLimitConstraint(),\r\n            JointLimitConstraint(),\r\n        ]\r\n\r\n        # Context providers\r\n        self.robot_state = None\r\n        self.scene_objects = []\r\n\r\n        # Subscribers\r\n        self.action_sub = self.create_subscription(\r\n            String, '/grounding/action', self.action_callback, 10\r\n        )\r\n        self.robot_state_sub = self.create_subscription(\r\n            JointState, '/joint_states', self.robot_state_callback, 10\r\n        )\r\n\r\n        # Publishers\r\n        self.safe_action_pub = self.create_publisher(\r\n            String, '/safety/approved_action', 10\r\n        )\r\n        self.rejection_pub = self.create_publisher(\r\n            String, '/safety/rejection', 10\r\n        )\r\n\r\n        self.get_logger().info('Safety filter ready')\r\n\r\n    def action_callback(self, msg: String):\r\n        \"\"\"Check action against all safety constraints.\"\"\"\r\n        action = json.loads(msg.data)\r\n        context = self.build_context()\r\n\r\n        result = SafetyCheckResult(is_safe=True)\r\n\r\n        # Check all constraints\r\n        for constraint in self.constraints:\r\n            violations = constraint.check(action, context)\r\n            for v in violations:\r\n                result.add_violation(v)\r\n                self.get_logger().warn(\r\n                    f'Safety: {constraint.name} - {v.message}'\r\n                )\r\n\r\n        if result.is_safe:\r\n            # Publish approved action\r\n            self.safe_action_pub.publish(msg)\r\n            self.get_logger().info('Action approved by safety filter')\r\n        else:\r\n            # Publish rejection with details\r\n            rejection = {\r\n                'original_action': action,\r\n                'violations': [\r\n                    {\r\n                        'constraint': v.constraint_name,\r\n                        'level': v.level.name,\r\n                        'message': v.message,\r\n                        'suggested_fix': v.suggested_fix\r\n                    }\r\n                    for v in result.violations\r\n                    if v.level >= SafetyLevel.VIOLATION\r\n                ]\r\n            }\r\n            rejection_msg = String()\r\n            rejection_msg.data = json.dumps(rejection)\r\n            self.rejection_pub.publish(rejection_msg)\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"workspace",children:"Workspace Boundary Checking"}),"\n",(0,i.jsx)(n.h3,{id:"cartesian-workspace-limits",children:"Cartesian Workspace Limits"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"class WorkspaceBoundaryConstraint(SafetyConstraint):\r\n    \"\"\"Ensure positions are within robot workspace.\"\"\"\r\n\r\n    def __init__(self):\r\n        # Define workspace as axis-aligned bounding box\r\n        # Values should come from robot URDF/configuration\r\n        self.workspace_min = np.array([0.1, -0.6, 0.0])   # x, y, z min\r\n        self.workspace_max = np.array([0.9, 0.6, 1.2])    # x, y, z max\r\n\r\n        # Danger zones (e.g., near electronics, human workspace)\r\n        self.danger_zones = [\r\n            {'center': np.array([0.5, 0.5, 0.8]), 'radius': 0.1},  # Example\r\n        ]\r\n\r\n    @property\r\n    def name(self) -> str:\r\n        return \"workspace_boundary\"\r\n\r\n    def check(\r\n        self,\r\n        action: dict,\r\n        context: dict\r\n    ) -> List[SafetyViolation]:\r\n        violations = []\r\n\r\n        # Extract target position from action\r\n        position = self.extract_position(action)\r\n        if position is None:\r\n            return violations  # No position to check\r\n\r\n        position = np.array(position)\r\n\r\n        # Check bounding box\r\n        if np.any(position < self.workspace_min):\r\n            axis = ['x', 'y', 'z'][np.argmin(position - self.workspace_min)]\r\n            violations.append(SafetyViolation(\r\n                constraint_name=self.name,\r\n                level=SafetyLevel.VIOLATION,\r\n                message=f\"Position {axis}={position[['x','y','z'].index(axis)]:.2f} \"\r\n                        f\"below minimum {self.workspace_min[['x','y','z'].index(axis)]:.2f}\",\r\n                details={'position': position.tolist(), 'limit': 'min'},\r\n                suggested_fix=f\"Increase {axis} to at least {self.workspace_min[['x','y','z'].index(axis)]:.2f}\"\r\n            ))\r\n\r\n        if np.any(position > self.workspace_max):\r\n            axis = ['x', 'y', 'z'][np.argmax(position - self.workspace_max)]\r\n            violations.append(SafetyViolation(\r\n                constraint_name=self.name,\r\n                level=SafetyLevel.VIOLATION,\r\n                message=f\"Position {axis}={position[['x','y','z'].index(axis)]:.2f} \"\r\n                        f\"above maximum {self.workspace_max[['x','y','z'].index(axis)]:.2f}\",\r\n                details={'position': position.tolist(), 'limit': 'max'},\r\n                suggested_fix=f\"Decrease {axis} to at most {self.workspace_max[['x','y','z'].index(axis)]:.2f}\"\r\n            ))\r\n\r\n        # Check danger zones\r\n        for i, zone in enumerate(self.danger_zones):\r\n            distance = np.linalg.norm(position - zone['center'])\r\n            if distance < zone['radius']:\r\n                violations.append(SafetyViolation(\r\n                    constraint_name=self.name,\r\n                    level=SafetyLevel.VIOLATION,\r\n                    message=f\"Position inside danger zone {i}\",\r\n                    details={'zone': i, 'distance': distance},\r\n                    suggested_fix=\"Move target position away from restricted area\"\r\n                ))\r\n\r\n        return violations\r\n\r\n    def extract_position(self, action: dict) -> Optional[List[float]]:\r\n        \"\"\"Extract target position from various action formats.\"\"\"\r\n        # From goal pose\r\n        if 'goal' in action and 'pose' in action['goal']:\r\n            pos = action['goal']['pose'].get('position')\r\n            if pos:\r\n                return [pos.get('x', 0), pos.get('y', 0), pos.get('z', 0)]\r\n\r\n        # From parameters\r\n        params = action.get('parameters', {})\r\n        if 'position' in params:\r\n            return params['position']\r\n\r\n        return None\n"})}),"\n",(0,i.jsx)(n.h3,{id:"joint-limit-checking",children:"Joint Limit Checking"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"class JointLimitConstraint(SafetyConstraint):\r\n    \"\"\"Ensure joint positions are within limits.\"\"\"\r\n\r\n    def __init__(self):\r\n        # Load from URDF or configuration\r\n        self.joint_limits = {\r\n            'joint1': {'min': -3.14, 'max': 3.14},\r\n            'joint2': {'min': -2.0, 'max': 2.0},\r\n            'joint3': {'min': -2.5, 'max': 2.5},\r\n            'joint4': {'min': -3.14, 'max': 3.14},\r\n            'joint5': {'min': -2.0, 'max': 2.0},\r\n            'joint6': {'min': -3.14, 'max': 3.14},\r\n        }\r\n\r\n    @property\r\n    def name(self) -> str:\r\n        return \"joint_limits\"\r\n\r\n    def check(\r\n        self,\r\n        action: dict,\r\n        context: dict\r\n    ) -> List[SafetyViolation]:\r\n        violations = []\r\n\r\n        # Check if action specifies joint targets\r\n        joint_targets = action.get('joint_positions', {})\r\n\r\n        for joint_name, target in joint_targets.items():\r\n            if joint_name not in self.joint_limits:\r\n                continue\r\n\r\n            limits = self.joint_limits[joint_name]\r\n            if target < limits['min']:\r\n                violations.append(SafetyViolation(\r\n                    constraint_name=self.name,\r\n                    level=SafetyLevel.VIOLATION,\r\n                    message=f\"{joint_name} target {target:.2f} below minimum {limits['min']:.2f}\",\r\n                    suggested_fix=f\"Set {joint_name} to at least {limits['min']:.2f}\"\r\n                ))\r\n            elif target > limits['max']:\r\n                violations.append(SafetyViolation(\r\n                    constraint_name=self.name,\r\n                    level=SafetyLevel.VIOLATION,\r\n                    message=f\"{joint_name} target {target:.2f} above maximum {limits['max']:.2f}\",\r\n                    suggested_fix=f\"Set {joint_name} to at most {limits['max']:.2f}\"\r\n                ))\r\n\r\n        return violations\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"velocity",children:"Velocity and Acceleration Limits"}),"\n",(0,i.jsx)(n.h3,{id:"motion-limit-checking",children:"Motion Limit Checking"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"class VelocityLimitConstraint(SafetyConstraint):\r\n    \"\"\"Ensure velocities are within safe limits.\"\"\"\r\n\r\n    def __init__(self):\r\n        # Cartesian velocity limits (m/s)\r\n        self.max_linear_velocity = 0.5\r\n        self.max_angular_velocity = 1.0  # rad/s\r\n\r\n        # Joint velocity limits (rad/s)\r\n        self.max_joint_velocity = {\r\n            'joint1': 2.0,\r\n            'joint2': 2.0,\r\n            'joint3': 2.0,\r\n            'joint4': 3.0,\r\n            'joint5': 3.0,\r\n            'joint6': 3.0,\r\n        }\r\n\r\n        # Reduced limits when near humans\r\n        self.human_proximity_factor = 0.5\r\n\r\n    @property\r\n    def name(self) -> str:\r\n        return \"velocity_limits\"\r\n\r\n    def check(\r\n        self,\r\n        action: dict,\r\n        context: dict\r\n    ) -> List[SafetyViolation]:\r\n        violations = []\r\n\r\n        # Check requested speed\r\n        speed = action.get('parameters', {}).get('speed')\r\n        if speed is not None:\r\n            # Adjust limit if human nearby\r\n            effective_limit = self.max_linear_velocity\r\n            if context.get('human_nearby', False):\r\n                effective_limit *= self.human_proximity_factor\r\n\r\n            if speed > effective_limit:\r\n                violations.append(SafetyViolation(\r\n                    constraint_name=self.name,\r\n                    level=SafetyLevel.VIOLATION,\r\n                    message=f\"Requested speed {speed:.2f} m/s exceeds \"\r\n                            f\"limit {effective_limit:.2f} m/s\",\r\n                    details={\r\n                        'requested': speed,\r\n                        'limit': effective_limit,\r\n                        'human_nearby': context.get('human_nearby', False)\r\n                    },\r\n                    suggested_fix=f\"Reduce speed to {effective_limit:.2f} m/s or less\"\r\n                ))\r\n\r\n        return violations\r\n\r\n\r\nclass AccelerationLimitConstraint(SafetyConstraint):\r\n    \"\"\"Ensure accelerations are within safe limits.\"\"\"\r\n\r\n    def __init__(self):\r\n        self.max_linear_acceleration = 1.0   # m/s\xb2\r\n        self.max_angular_acceleration = 2.0  # rad/s\xb2\r\n\r\n    @property\r\n    def name(self) -> str:\r\n        return \"acceleration_limits\"\r\n\r\n    def check(\r\n        self,\r\n        action: dict,\r\n        context: dict\r\n    ) -> List[SafetyViolation]:\r\n        violations = []\r\n\r\n        # Check acceleration parameter if specified\r\n        accel = action.get('parameters', {}).get('acceleration')\r\n        if accel is not None and accel > self.max_linear_acceleration:\r\n            violations.append(SafetyViolation(\r\n                constraint_name=self.name,\r\n                level=SafetyLevel.VIOLATION,\r\n                message=f\"Requested acceleration {accel:.2f} m/s\xb2 exceeds \"\r\n                        f\"limit {self.max_linear_acceleration:.2f} m/s\xb2\",\r\n                suggested_fix=f\"Reduce acceleration to {self.max_linear_acceleration:.2f} m/s\xb2 or less\"\r\n            ))\r\n\r\n        return violations\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"collision",children:"Collision Checking"}),"\n",(0,i.jsx)(n.h3,{id:"perception-based-collision-avoidance",children:"Perception-Based Collision Avoidance"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"class CollisionConstraint(SafetyConstraint):\r\n    \"\"\"Check for potential collisions using perception data.\"\"\"\r\n\r\n    def __init__(self):\r\n        self.safety_margin = 0.05  # 5cm clearance\r\n        self.robot_collision_spheres = [\r\n            # Simplified robot model as spheres\r\n            {'link': 'base_link', 'radius': 0.15, 'offset': [0, 0, 0.1]},\r\n            {'link': 'link1', 'radius': 0.08, 'offset': [0, 0, 0]},\r\n            {'link': 'link2', 'radius': 0.08, 'offset': [0, 0, 0]},\r\n            {'link': 'ee_link', 'radius': 0.05, 'offset': [0, 0, 0]},\r\n        ]\r\n\r\n    @property\r\n    def name(self) -> str:\r\n        return \"collision\"\r\n\r\n    def check(\r\n        self,\r\n        action: dict,\r\n        context: dict\r\n    ) -> List[SafetyViolation]:\r\n        violations = []\r\n\r\n        # Get scene objects from perception\r\n        scene_objects = context.get('scene_objects', [])\r\n        target_position = self.extract_target_position(action)\r\n\r\n        if target_position is None:\r\n            return violations\r\n\r\n        # Check distance to each detected object\r\n        for obj in scene_objects:\r\n            obj_pos = np.array(obj['position'])\r\n            obj_radius = obj.get('radius', 0.1)  # Estimated object size\r\n\r\n            distance = np.linalg.norm(target_position - obj_pos)\r\n            min_clearance = self.safety_margin + obj_radius\r\n\r\n            if distance < min_clearance:\r\n                violations.append(SafetyViolation(\r\n                    constraint_name=self.name,\r\n                    level=SafetyLevel.VIOLATION,\r\n                    message=f\"Target position too close to {obj.get('class', 'object')} \"\r\n                            f\"(distance: {distance:.2f}m, required: {min_clearance:.2f}m)\",\r\n                    details={\r\n                        'object': obj.get('class', 'unknown'),\r\n                        'distance': distance,\r\n                        'required_clearance': min_clearance\r\n                    },\r\n                    suggested_fix=\"Adjust target position away from obstacle\"\r\n                ))\r\n\r\n        # Check for collision along path (simplified)\r\n        current_position = context.get('ee_position')\r\n        if current_position is not None:\r\n            path_collisions = self.check_path_collision(\r\n                np.array(current_position),\r\n                target_position,\r\n                scene_objects\r\n            )\r\n            violations.extend(path_collisions)\r\n\r\n        return violations\r\n\r\n    def check_path_collision(\r\n        self,\r\n        start: np.ndarray,\r\n        end: np.ndarray,\r\n        obstacles: List[dict]\r\n    ) -> List[SafetyViolation]:\r\n        \"\"\"Check for collisions along straight-line path.\"\"\"\r\n        violations = []\r\n\r\n        # Sample points along path\r\n        num_samples = 10\r\n        for i in range(num_samples):\r\n            t = i / (num_samples - 1)\r\n            point = start + t * (end - start)\r\n\r\n            for obj in obstacles:\r\n                obj_pos = np.array(obj['position'])\r\n                obj_radius = obj.get('radius', 0.1)\r\n                distance = np.linalg.norm(point - obj_pos)\r\n\r\n                if distance < (self.safety_margin + obj_radius):\r\n                    violations.append(SafetyViolation(\r\n                        constraint_name=self.name,\r\n                        level=SafetyLevel.VIOLATION,\r\n                        message=f\"Path collision with {obj.get('class', 'object')} \"\r\n                                f\"at t={t:.1f}\",\r\n                        details={'path_fraction': t, 'object': obj.get('class')},\r\n                        suggested_fix=\"Plan path around obstacle\"\r\n                    ))\r\n                    break  # One path collision is enough\r\n\r\n        return violations\r\n\r\n    def extract_target_position(self, action: dict) -> Optional[np.ndarray]:\r\n        \"\"\"Extract target position from action.\"\"\"\r\n        params = action.get('parameters', {})\r\n        if 'position' in params:\r\n            return np.array(params['position'])\r\n\r\n        goal = action.get('goal', {})\r\n        if 'pose' in goal:\r\n            pos = goal['pose'].get('position', {})\r\n            return np.array([pos.get('x', 0), pos.get('y', 0), pos.get('z', 0)])\r\n\r\n        return None\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"force",children:"Force Limits and Contact Safety"}),"\n",(0,i.jsx)(n.h3,{id:"force-limited-operations",children:"Force-Limited Operations"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"class ForceLimitConstraint(SafetyConstraint):\r\n    \"\"\"Ensure force commands are within safe limits.\"\"\"\r\n\r\n    def __init__(self):\r\n        # Maximum forces by context\r\n        self.max_grip_force_default = 50.0  # N\r\n        self.max_grip_force_fragile = 10.0  # N\r\n        self.max_contact_force = 20.0       # N\r\n\r\n        # Fragile object classes\r\n        self.fragile_classes = {'glass', 'ceramic', 'egg', 'bulb', 'phone'}\r\n\r\n    @property\r\n    def name(self) -> str:\r\n        return \"force_limits\"\r\n\r\n    def check(\r\n        self,\r\n        action: dict,\r\n        context: dict\r\n    ) -> List[SafetyViolation]:\r\n        violations = []\r\n\r\n        # Check grip force\r\n        action_type = action.get('action_type')\r\n        params = action.get('parameters', {})\r\n\r\n        if action_type == 'close_gripper':\r\n            requested_force = params.get('force', self.max_grip_force_default)\r\n            target_object = context.get('held_object_class')\r\n\r\n            # Determine appropriate limit\r\n            if target_object in self.fragile_classes:\r\n                max_force = self.max_grip_force_fragile\r\n            else:\r\n                max_force = self.max_grip_force_default\r\n\r\n            if requested_force > max_force:\r\n                violations.append(SafetyViolation(\r\n                    constraint_name=self.name,\r\n                    level=SafetyLevel.VIOLATION,\r\n                    message=f\"Grip force {requested_force:.1f}N exceeds \"\r\n                            f\"limit {max_force:.1f}N for {target_object or 'object'}\",\r\n                    details={\r\n                        'requested': requested_force,\r\n                        'limit': max_force,\r\n                        'object_class': target_object\r\n                    },\r\n                    suggested_fix=f\"Reduce grip force to {max_force:.1f}N or less\"\r\n                ))\r\n\r\n        return violations\n"})}),"\n",(0,i.jsx)(n.h3,{id:"payload-checking",children:"Payload Checking"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"class PayloadConstraint(SafetyConstraint):\r\n    \"\"\"Ensure payload is within robot capacity.\"\"\"\r\n\r\n    def __init__(self):\r\n        self.max_payload_kg = 5.0\r\n\r\n        # Known object weights (from perception or database)\r\n        self.known_weights = {\r\n            'mug': 0.3,\r\n            'bottle': 0.5,\r\n            'book': 0.8,\r\n            'laptop': 2.5,\r\n            'box': 3.0,  # Default box weight\r\n        }\r\n\r\n    @property\r\n    def name(self) -> str:\r\n        return \"payload\"\r\n\r\n    def check(\r\n        self,\r\n        action: dict,\r\n        context: dict\r\n    ) -> List[SafetyViolation]:\r\n        violations = []\r\n\r\n        if action.get('action_type') != 'pick':\r\n            return violations\r\n\r\n        target = action.get('target', '')\r\n\r\n        # Estimate weight\r\n        estimated_weight = self.estimate_weight(target, context)\r\n\r\n        if estimated_weight > self.max_payload_kg:\r\n            violations.append(SafetyViolation(\r\n                constraint_name=self.name,\r\n                level=SafetyLevel.VIOLATION,\r\n                message=f\"Estimated payload {estimated_weight:.1f}kg exceeds \"\r\n                        f\"limit {self.max_payload_kg:.1f}kg\",\r\n                details={\r\n                    'estimated_weight': estimated_weight,\r\n                    'limit': self.max_payload_kg,\r\n                    'target': target\r\n                },\r\n                suggested_fix=\"Cannot pick this object - too heavy\"\r\n            ))\r\n\r\n        return violations\r\n\r\n    def estimate_weight(self, target: str, context: dict) -> float:\r\n        \"\"\"Estimate object weight from class and perception.\"\"\"\r\n        # Check known weights\r\n        for known_class, weight in self.known_weights.items():\r\n            if known_class in target.lower():\r\n                return weight\r\n\r\n        # Default to unknown weight warning\r\n        return 1.0  # Conservative default\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"responses",children:"Safety Rejection Responses"}),"\n",(0,i.jsx)(n.h3,{id:"informative-rejection-messages",children:"Informative Rejection Messages"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'class SafetyResponseGenerator:\r\n    """Generate informative responses for safety rejections."""\r\n\r\n    def generate_response(\r\n        self,\r\n        original_command: str,\r\n        violations: List[SafetyViolation]\r\n    ) -> str:\r\n        """Generate user-friendly rejection message."""\r\n        if not violations:\r\n            return "Command approved."\r\n\r\n        # Group by severity\r\n        critical = [v for v in violations if v.level == SafetyLevel.CRITICAL]\r\n        blocking = [v for v in violations if v.level == SafetyLevel.VIOLATION]\r\n\r\n        if critical:\r\n            return self.format_critical(critical)\r\n\r\n        if blocking:\r\n            return self.format_blocking(blocking)\r\n\r\n        return "Command has warnings but can proceed."\r\n\r\n    def format_critical(self, violations: List[SafetyViolation]) -> str:\r\n        """Format critical safety message."""\r\n        messages = [v.message for v in violations]\r\n        return f"EMERGENCY STOP: {\'; \'.join(messages)}"\r\n\r\n    def format_blocking(self, violations: List[SafetyViolation]) -> str:\r\n        """Format blocking violation message."""\r\n        response_parts = ["I cannot execute this command safely:"]\r\n\r\n        for v in violations[:3]:  # Limit to 3 most important\r\n            response_parts.append(f"  - {v.message}")\r\n            if v.suggested_fix:\r\n                response_parts.append(f"    Suggestion: {v.suggested_fix}")\r\n\r\n        if len(violations) > 3:\r\n            response_parts.append(f"  - ...and {len(violations) - 3} more issues")\r\n\r\n        return "\\n".join(response_parts)\n'})}),"\n",(0,i.jsx)(n.h3,{id:"speech-synthesis-integration",children:"Speech Synthesis Integration"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"class SafetySpeechNode(Node):\r\n    \"\"\"Announce safety rejections via speech.\"\"\"\r\n\r\n    def __init__(self):\r\n        super().__init__('safety_speech')\r\n\r\n        self.rejection_sub = self.create_subscription(\r\n            String, '/safety/rejection', self.rejection_callback, 10\r\n        )\r\n\r\n        self.speech_pub = self.create_publisher(\r\n            String, '/tts/input', 10\r\n        )\r\n\r\n        self.response_generator = SafetyResponseGenerator()\r\n\r\n    def rejection_callback(self, msg: String):\r\n        \"\"\"Convert rejection to speech.\"\"\"\r\n        rejection = json.loads(msg.data)\r\n\r\n        violations = [\r\n            SafetyViolation(\r\n                constraint_name=v['constraint'],\r\n                level=SafetyLevel[v['level']],\r\n                message=v['message'],\r\n                suggested_fix=v.get('suggested_fix')\r\n            )\r\n            for v in rejection.get('violations', [])\r\n        ]\r\n\r\n        speech_text = self.response_generator.generate_response(\r\n            rejection.get('original_command', ''),\r\n            violations\r\n        )\r\n\r\n        speech_msg = String()\r\n        speech_msg.data = speech_text\r\n        self.speech_pub.publish(speech_msg)\r\n\r\n        self.get_logger().info(f'Safety announcement: {speech_text}')\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"monitoring",children:"Runtime Safety Monitoring"}),"\n",(0,i.jsx)(n.h3,{id:"continuous-safety-watch",children:"Continuous Safety Watch"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'class RuntimeSafetyMonitor(Node):\r\n    """Continuous monitoring during execution."""\r\n\r\n    def __init__(self):\r\n        super().__init__(\'runtime_safety\')\r\n\r\n        # State\r\n        self.is_executing = False\r\n        self.current_action = None\r\n\r\n        # Subscribers\r\n        self.joint_state_sub = self.create_subscription(\r\n            JointState, \'/joint_states\', self.joint_state_callback, 10\r\n        )\r\n        self.wrench_sub = self.create_subscription(\r\n            WrenchStamped, \'/ft_sensor\', self.wrench_callback, 10\r\n        )\r\n\r\n        # Emergency stop publisher\r\n        self.estop_pub = self.create_publisher(\r\n            Bool, \'/emergency_stop\', 10\r\n        )\r\n\r\n        # Limits\r\n        self.force_threshold = 50.0  # N\r\n        self.torque_threshold = 10.0  # Nm\r\n\r\n        # Timer for periodic checks\r\n        self.create_timer(0.01, self.monitor_callback)  # 100 Hz\r\n\r\n        self.get_logger().info(\'Runtime safety monitor active\')\r\n\r\n    def wrench_callback(self, msg: WrenchStamped):\r\n        """Check force/torque limits."""\r\n        force = np.array([\r\n            msg.wrench.force.x,\r\n            msg.wrench.force.y,\r\n            msg.wrench.force.z\r\n        ])\r\n        torque = np.array([\r\n            msg.wrench.torque.x,\r\n            msg.wrench.torque.y,\r\n            msg.wrench.torque.z\r\n        ])\r\n\r\n        force_magnitude = np.linalg.norm(force)\r\n        torque_magnitude = np.linalg.norm(torque)\r\n\r\n        if force_magnitude > self.force_threshold:\r\n            self.trigger_emergency_stop(\r\n                f"Force limit exceeded: {force_magnitude:.1f}N > {self.force_threshold:.1f}N"\r\n            )\r\n\r\n        if torque_magnitude > self.torque_threshold:\r\n            self.trigger_emergency_stop(\r\n                f"Torque limit exceeded: {torque_magnitude:.1f}Nm > {self.torque_threshold:.1f}Nm"\r\n            )\r\n\r\n    def trigger_emergency_stop(self, reason: str):\r\n        """Trigger emergency stop."""\r\n        self.get_logger().error(f\'EMERGENCY STOP: {reason}\')\r\n\r\n        msg = Bool()\r\n        msg.data = True\r\n        self.estop_pub.publish(msg)\r\n\r\n        # Log incident\r\n        self.log_safety_incident(reason)\r\n\r\n    def log_safety_incident(self, reason: str):\r\n        """Log safety incident for analysis."""\r\n        import time\r\n        incident = {\r\n            \'timestamp\': time.time(),\r\n            \'reason\': reason,\r\n            \'action\': self.current_action,\r\n            \'robot_state\': \'captured_state_here\'\r\n        }\r\n        self.get_logger().error(f\'Safety incident: {json.dumps(incident)}\')\n'})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,i.jsx)(n.p,{children:"This chapter covered safety constraints for AI-generated robot commands:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Safety philosophy"})," requires constraints to override AI outputs\u2014refuse rather than act unsafely."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Defense in depth"})," uses multiple layers: prompt constraints, schema validation, safety filter, runtime monitoring."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Workspace checking"})," validates positions against bounds and danger zones."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Velocity/acceleration limits"})," prevent dangerous motion speeds, with dynamic adjustment for human proximity."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Collision checking"})," uses perception to verify clearance along planned paths."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Force limits"})," prevent damage to objects and robot, with context-aware thresholds."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Runtime monitoring"})," provides continuous safety supervision during execution."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"safety-callout",children:"Safety Callout"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"This safety layer is CRITICAL but not SUFFICIENT:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"It assumes perception is accurate (but VLM can hallucinate)"}),"\n",(0,i.jsx)(n.li,{children:"It assumes workspace is calibrated (but calibration drifts)"}),"\n",(0,i.jsx)(n.li,{children:"It assumes force sensors work (but sensors fail)"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"For real deployment, add:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Redundant sensors"}),"\n",(0,i.jsx)(n.li,{children:"Hardware e-stop"}),"\n",(0,i.jsx)(n.li,{children:"Human supervision"}),"\n",(0,i.jsx)(n.li,{children:"Regular calibration verification"}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"self-assessment-questions",children:"Self-Assessment Questions"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Defense in Depth"}),': The LLM prompt says "max speed 0.5 m/s" but the safety filter also checks. Why both?']}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"False Positives"}),": Your collision check rejects a valid command because perception falsely detected an obstacle. How do you balance safety vs. functionality?"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Human Proximity"}),": The robot is 2 meters from a human. Should velocity limits be reduced? At what distance?"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Payload Estimation"}),": You don't know the weight of an unknown object. Should you attempt to pick it? What's the safe approach?"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Emergency Stop"}),": The force sensor reads 60N during a pick operation. Should you immediately stop, or could this be normal contact?"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"whats-next",children:"What's Next"}),"\n",(0,i.jsxs)(n.p,{children:["In ",(0,i.jsx)(n.a,{href:"/module-5/chapter-6-failure-handling",children:"Chapter 6: Failure Handling"}),", you'll implement robust failure detection and recovery strategies for when commands fail despite passing safety checks."]})]})}function d(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(f,{...e})}):f(e)}},8453(e,n,r){r.d(n,{R:()=>a,x:()=>o});var t=r(6540);const i={},s=t.createContext(i);function a(e){const n=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);