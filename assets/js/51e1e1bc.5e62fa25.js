"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[7924],{8453(e,n,r){r.d(n,{R:()=>i,x:()=>o});var a=r(6540);const s={},t=a.createContext(s);function i(e){const n=a.useContext(t);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),a.createElement(t.Provider,{value:n},e.children)}},9616(e,n,r){r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>_,frontMatter:()=>i,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"capstone/chapter-3-navigation","title":"Chapter 3: Navigation System","description":"Chapter Goal","source":"@site/docs/capstone/chapter-3-navigation.md","sourceDirName":"capstone","slug":"/capstone/chapter-3-navigation","permalink":"/Master-Robotics-AI/textbook/capstone/chapter-3-navigation","draft":false,"unlisted":false,"editUrl":"https://github.com/HasnainCodeHub/Master-Robotics-AI/tree/main/docs/docs/capstone/chapter-3-navigation.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"id":"chapter-3-navigation","title":"Chapter 3: Navigation System","sidebar_label":"3. Navigation","sidebar_position":4},"sidebar":"textbookSidebar","previous":{"title":"2. Robot Setup","permalink":"/Master-Robotics-AI/textbook/capstone/chapter-2-robot-setup"},"next":{"title":"4. Manipulation","permalink":"/Master-Robotics-AI/textbook/capstone/chapter-4-manipulation"}}');var s=r(4848),t=r(8453);const i={id:"chapter-3-navigation",title:"Chapter 3: Navigation System",sidebar_label:"3. Navigation",sidebar_position:4},o="Chapter 3: Navigation System Implementation",l={},c=[{value:"Chapter Goal",id:"chapter-goal",level:2},{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Navigation Architecture",id:"architecture",level:2},{value:"System Overview",id:"system-overview",level:3},{value:"Data Flow",id:"data-flow",level:3},{value:"VSLAM Configuration",id:"vslam",level:2},{value:"Isaac ROS Visual SLAM",id:"isaac-ros-visual-slam",level:3},{value:"VSLAM Launch",id:"vslam-launch",level:3},{value:"VSLAM Monitoring",id:"vslam-monitoring",level:3},{value:"Nav2 Configuration",id:"nav2",level:2},{value:"Navigation Parameters",id:"navigation-parameters",level:3},{value:"Nav2 Launch",id:"nav2-launch",level:3},{value:"Navigation Action Server",id:"action-server",level:2},{value:"Custom Navigation Interface",id:"custom-navigation-interface",level:3},{value:"Dynamic Obstacle Avoidance",id:"obstacle-avoidance",level:2},{value:"Obstacle Detection and Tracking",id:"obstacle-detection-and-tracking",level:3},{value:"Navigation Recovery Behaviors",id:"recovery",level:2},{value:"Recovery Behavior Implementation",id:"recovery-behavior-implementation",level:3},{value:"Summary",id:"summary",level:2},{value:"Navigation Checklist",id:"navigation-checklist",level:2},{value:"What&#39;s Next",id:"whats-next",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",input:"input",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"chapter-3-navigation-system-implementation",children:"Chapter 3: Navigation System Implementation"})}),"\n",(0,s.jsx)(n.h2,{id:"chapter-goal",children:"Chapter Goal"}),"\n",(0,s.jsxs)(n.p,{children:["By the end of this chapter, you will have ",(0,s.jsx)(n.strong,{children:"implemented a complete navigation system"})," using VSLAM for localization, Nav2 for path planning, and dynamic obstacle avoidance for safe autonomous navigation."]}),"\n",(0,s.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,s.jsx)(n.p,{children:"After completing this chapter, you will be able to:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"ID"}),(0,s.jsx)(n.th,{children:"Objective"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"3.1"}),(0,s.jsx)(n.td,{children:"Configure VSLAM for robot localization"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"3.2"}),(0,s.jsx)(n.td,{children:"Set up Nav2 for path planning and execution"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"3.3"}),(0,s.jsx)(n.td,{children:"Implement dynamic obstacle avoidance"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"3.4"}),(0,s.jsx)(n.td,{children:"Create ROS 2 action interfaces for navigation"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"3.5"}),(0,s.jsx)(n.td,{children:"Handle navigation failures and recovery"})]})]})]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"architecture",children:"Navigation Architecture"}),"\n",(0,s.jsx)(n.h3,{id:"system-overview",children:"System Overview"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502                      NAVIGATION SYSTEM                                  \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502                                                                         \u2502\r\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                 \u2502\r\n\u2502  \u2502   VSLAM     \u2502\u2500\u2500\u2500\u25ba\u2502   Nav2      \u2502\u2500\u2500\u2500\u25ba\u2502   Local     \u2502                 \u2502\r\n\u2502  \u2502 Localization\u2502    \u2502  Planner    \u2502    \u2502  Controller \u2502                 \u2502\r\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                 \u2502\r\n\u2502        \u25b2                  \u25b2                  \u2502                          \u2502\r\n\u2502        \u2502                  \u2502                  \u25bc                          \u2502\r\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                 \u2502\r\n\u2502  \u2502  Stereo +   \u2502    \u2502  Costmap    \u2502    \u2502   cmd_vel   \u2502                 \u2502\r\n\u2502  \u2502    IMU      \u2502    \u2502  (LiDAR)    \u2502    \u2502   Output    \u2502                 \u2502\r\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                 \u2502\r\n\u2502                                                                         \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,s.jsx)(n.h3,{id:"data-flow",children:"Data Flow"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Stage"}),(0,s.jsx)(n.th,{children:"Input"}),(0,s.jsx)(n.th,{children:"Output"}),(0,s.jsx)(n.th,{children:"Rate"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"VSLAM"}),(0,s.jsx)(n.td,{children:"Stereo images, IMU"}),(0,s.jsx)(n.td,{children:"Odometry, pose"}),(0,s.jsx)(n.td,{children:"30 Hz"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Costmap"}),(0,s.jsx)(n.td,{children:"LiDAR scan, pose"}),(0,s.jsx)(n.td,{children:"Occupancy grid"}),(0,s.jsx)(n.td,{children:"10 Hz"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Global Planner"}),(0,s.jsx)(n.td,{children:"Goal, map"}),(0,s.jsx)(n.td,{children:"Path"}),(0,s.jsx)(n.td,{children:"On request"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Local Planner"}),(0,s.jsx)(n.td,{children:"Path, costmap"}),(0,s.jsx)(n.td,{children:"cmd_vel"}),(0,s.jsx)(n.td,{children:"20 Hz"})]})]})]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"vslam",children:"VSLAM Configuration"}),"\n",(0,s.jsx)(n.h3,{id:"isaac-ros-visual-slam",children:"Isaac ROS Visual SLAM"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:'# config/visual_slam_params.yaml\r\n\r\nvisual_slam_node:\r\n  ros__parameters:\r\n    # Camera configuration\r\n    enable_rectified_pose: true\r\n    enable_image_denoising: false\r\n\r\n    # IMU fusion\r\n    enable_imu_fusion: true\r\n    gyro_noise_density: 0.00016       # rad/s/sqrt(Hz)\r\n    gyro_random_walk: 0.000022        # rad/s^2/sqrt(Hz)\r\n    accel_noise_density: 0.0017       # m/s^2/sqrt(Hz)\r\n    accel_random_walk: 0.00019        # m/s^3/sqrt(Hz)\r\n    calibration_frequency: 200.0      # IMU rate\r\n\r\n    # Performance tuning\r\n    enable_verbosity: false\r\n    force_planar_mode: false\r\n    enable_observations_view: false\r\n    enable_landmarks_view: false\r\n\r\n    # Output configuration\r\n    map_frame: "map"\r\n    odom_frame: "odom"\r\n    base_frame: "base_link"\r\n    publish_odom_to_base_tf: true\r\n    publish_map_to_odom_tf: true\n'})}),"\n",(0,s.jsx)(n.h3,{id:"vslam-launch",children:"VSLAM Launch"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"# launch/vslam.launch.py\r\n\r\nfrom launch import LaunchDescription\r\nfrom launch_ros.actions import ComposableNodeContainer\r\nfrom launch_ros.descriptions import ComposableNode\r\n\r\ndef generate_launch_description():\r\n    return LaunchDescription([\r\n        ComposableNodeContainer(\r\n            name='vslam_container',\r\n            namespace='',\r\n            package='rclcpp_components',\r\n            executable='component_container_mt',\r\n            composable_node_descriptions=[\r\n                ComposableNode(\r\n                    package='isaac_ros_visual_slam',\r\n                    plugin='nvidia::isaac_ros::visual_slam::VisualSlamNode',\r\n                    name='visual_slam',\r\n                    parameters=['config/visual_slam_params.yaml'],\r\n                    remappings=[\r\n                        ('stereo_camera/left/image', '/camera/left/image'),\r\n                        ('stereo_camera/left/camera_info', '/camera/left/camera_info'),\r\n                        ('stereo_camera/right/image', '/camera/right/image'),\r\n                        ('stereo_camera/right/camera_info', '/camera/right/camera_info'),\r\n                        ('visual_slam/imu', '/imu'),\r\n                    ]\r\n                ),\r\n            ],\r\n            output='screen',\r\n        ),\r\n    ])\n"})}),"\n",(0,s.jsx)(n.h3,{id:"vslam-monitoring",children:"VSLAM Monitoring"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'#!/usr/bin/env python3\r\n"""Monitor VSLAM health and accuracy."""\r\n\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom nav_msgs.msg import Odometry\r\nfrom geometry_msgs.msg import PoseStamped\r\nimport numpy as np\r\n\r\n\r\nclass VSLAMMonitor(Node):\r\n    """Monitor VSLAM performance."""\r\n\r\n    def __init__(self):\r\n        super().__init__(\'vslam_monitor\')\r\n\r\n        # State\r\n        self.pose_history = []\r\n        self.velocity_history = []\r\n        self.last_pose_time = None\r\n\r\n        # Subscribers\r\n        self.odom_sub = self.create_subscription(\r\n            Odometry,\r\n            \'/visual_slam/tracking/odometry\',\r\n            self.odom_callback,\r\n            10\r\n        )\r\n\r\n        # Health check timer\r\n        self.create_timer(1.0, self.health_check)\r\n\r\n        # Thresholds\r\n        self.max_velocity = 2.0  # m/s - suspicious if exceeded\r\n        self.stale_threshold = 1.0  # seconds\r\n\r\n    def odom_callback(self, msg: Odometry):\r\n        """Process odometry update."""\r\n        current_time = self.get_clock().now()\r\n\r\n        # Extract pose\r\n        pose = msg.pose.pose\r\n        position = np.array([\r\n            pose.position.x,\r\n            pose.position.y,\r\n            pose.position.z\r\n        ])\r\n\r\n        # Extract velocity\r\n        velocity = np.array([\r\n            msg.twist.twist.linear.x,\r\n            msg.twist.twist.linear.y,\r\n            msg.twist.twist.linear.z\r\n        ])\r\n\r\n        # Store\r\n        self.pose_history.append({\r\n            \'time\': current_time,\r\n            \'position\': position\r\n        })\r\n        self.velocity_history.append(np.linalg.norm(velocity))\r\n\r\n        # Keep limited history\r\n        if len(self.pose_history) > 100:\r\n            self.pose_history.pop(0)\r\n            self.velocity_history.pop(0)\r\n\r\n        self.last_pose_time = current_time\r\n\r\n    def health_check(self):\r\n        """Check VSLAM health."""\r\n        current_time = self.get_clock().now()\r\n\r\n        # Check for stale data\r\n        if self.last_pose_time is not None:\r\n            age = (current_time - self.last_pose_time).nanoseconds / 1e9\r\n            if age > self.stale_threshold:\r\n                self.get_logger().warn(f\'VSLAM stale: {age:.2f}s since last update\')\r\n                return\r\n\r\n        # Check velocity sanity\r\n        if self.velocity_history:\r\n            max_vel = max(self.velocity_history[-10:])\r\n            if max_vel > self.max_velocity:\r\n                self.get_logger().warn(f\'Suspicious velocity: {max_vel:.2f} m/s\')\r\n\r\n        # Check tracking stability\r\n        if len(self.pose_history) >= 10:\r\n            positions = [p[\'position\'] for p in self.pose_history[-10:]]\r\n            variance = np.var(positions, axis=0)\r\n            if np.any(variance > 1.0):  # High variance indicates instability\r\n                self.get_logger().warn(f\'High pose variance: {variance}\')\r\n\r\n        self.get_logger().debug(\'VSLAM health: OK\')\n'})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"nav2",children:"Nav2 Configuration"}),"\n",(0,s.jsx)(n.h3,{id:"navigation-parameters",children:"Navigation Parameters"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:'# config/nav2_params.yaml\r\n\r\nbt_navigator:\r\n  ros__parameters:\r\n    use_sim_time: true\r\n    global_frame: map\r\n    robot_base_frame: base_link\r\n    odom_topic: /visual_slam/tracking/odometry\r\n    bt_loop_duration: 10\r\n    default_server_timeout: 20\r\n    enable_groot_monitoring: true\r\n    groot_zmq_publisher_port: 1666\r\n    groot_zmq_server_port: 1667\r\n    default_nav_to_pose_bt_xml: "navigate_to_pose_w_replanning_and_recovery.xml"\r\n\r\ncontroller_server:\r\n  ros__parameters:\r\n    use_sim_time: true\r\n    controller_frequency: 20.0\r\n    min_x_velocity_threshold: 0.001\r\n    min_y_velocity_threshold: 0.5\r\n    min_theta_velocity_threshold: 0.001\r\n    progress_checker_plugin: "progress_checker"\r\n    goal_checker_plugin: "goal_checker"\r\n    controller_plugins: ["FollowPath"]\r\n\r\n    # Progress checker\r\n    progress_checker:\r\n      plugin: "nav2_controller::SimpleProgressChecker"\r\n      required_movement_radius: 0.5\r\n      movement_time_allowance: 10.0\r\n\r\n    # Goal checker\r\n    goal_checker:\r\n      plugin: "nav2_controller::SimpleGoalChecker"\r\n      xy_goal_tolerance: 0.1\r\n      yaw_goal_tolerance: 0.1\r\n      stateful: true\r\n\r\n    # DWB controller\r\n    FollowPath:\r\n      plugin: "dwb_core::DWBLocalPlanner"\r\n      debug_trajectory_details: true\r\n      min_vel_x: 0.0\r\n      min_vel_y: 0.0\r\n      max_vel_x: 0.5\r\n      max_vel_y: 0.0\r\n      max_vel_theta: 1.0\r\n      min_speed_xy: 0.0\r\n      max_speed_xy: 0.5\r\n      min_speed_theta: 0.0\r\n      acc_lim_x: 1.0\r\n      acc_lim_y: 0.0\r\n      acc_lim_theta: 2.0\r\n      decel_lim_x: -1.5\r\n      decel_lim_y: 0.0\r\n      decel_lim_theta: -2.5\r\n      vx_samples: 20\r\n      vy_samples: 5\r\n      vtheta_samples: 20\r\n      sim_time: 1.5\r\n      transform_tolerance: 0.2\r\n      xy_goal_tolerance: 0.1\r\n      critics: ["RotateToGoal", "Oscillation", "BaseObstacle", "GoalAlign", "PathAlign", "PathDist", "GoalDist"]\r\n\r\nplanner_server:\r\n  ros__parameters:\r\n    use_sim_time: true\r\n    planner_plugins: ["GridBased"]\r\n    GridBased:\r\n      plugin: "nav2_navfn_planner/NavfnPlanner"\r\n      tolerance: 0.5\r\n      use_astar: true\r\n      allow_unknown: true\r\n\r\nlocal_costmap:\r\n  local_costmap:\r\n    ros__parameters:\r\n      use_sim_time: true\r\n      global_frame: odom\r\n      robot_base_frame: base_link\r\n      rolling_window: true\r\n      width: 3\r\n      height: 3\r\n      resolution: 0.05\r\n      robot_radius: 0.35\r\n      plugins: ["obstacle_layer", "inflation_layer"]\r\n      obstacle_layer:\r\n        plugin: "nav2_costmap_2d::ObstacleLayer"\r\n        enabled: true\r\n        observation_sources: scan\r\n        scan:\r\n          topic: /scan\r\n          max_obstacle_height: 2.0\r\n          clearing: true\r\n          marking: true\r\n          data_type: "LaserScan"\r\n          raytrace_max_range: 3.0\r\n          raytrace_min_range: 0.0\r\n          obstacle_max_range: 2.5\r\n          obstacle_min_range: 0.0\r\n      inflation_layer:\r\n        plugin: "nav2_costmap_2d::InflationLayer"\r\n        cost_scaling_factor: 3.0\r\n        inflation_radius: 0.55\r\n\r\nglobal_costmap:\r\n  global_costmap:\r\n    ros__parameters:\r\n      use_sim_time: true\r\n      global_frame: map\r\n      robot_base_frame: base_link\r\n      robot_radius: 0.35\r\n      resolution: 0.05\r\n      track_unknown_space: true\r\n      plugins: ["static_layer", "obstacle_layer", "inflation_layer"]\r\n      static_layer:\r\n        plugin: "nav2_costmap_2d::StaticLayer"\r\n        map_subscribe_transient_local: true\r\n      obstacle_layer:\r\n        plugin: "nav2_costmap_2d::ObstacleLayer"\r\n        enabled: true\r\n        observation_sources: scan\r\n        scan:\r\n          topic: /scan\r\n          max_obstacle_height: 2.0\r\n          clearing: true\r\n          marking: true\r\n      inflation_layer:\r\n        plugin: "nav2_costmap_2d::InflationLayer"\r\n        cost_scaling_factor: 3.0\r\n        inflation_radius: 0.55\n'})}),"\n",(0,s.jsx)(n.h3,{id:"nav2-launch",children:"Nav2 Launch"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"# launch/navigation.launch.py\r\n\r\nfrom launch import LaunchDescription\r\nfrom launch.actions import IncludeLaunchDescription\r\nfrom launch.launch_description_sources import PythonLaunchDescriptionSource\r\nfrom launch_ros.actions import Node\r\nfrom ament_index_python.packages import get_package_share_directory\r\nimport os\r\n\r\ndef generate_launch_description():\r\n    nav2_dir = get_package_share_directory('nav2_bringup')\r\n    params_file = os.path.join(\r\n        get_package_share_directory('humanoid_navigation'),\r\n        'config',\r\n        'nav2_params.yaml'\r\n    )\r\n\r\n    return LaunchDescription([\r\n        # Nav2 stack\r\n        IncludeLaunchDescription(\r\n            PythonLaunchDescriptionSource(\r\n                os.path.join(nav2_dir, 'launch', 'navigation_launch.py')\r\n            ),\r\n            launch_arguments={\r\n                'params_file': params_file,\r\n                'use_sim_time': 'true',\r\n            }.items()\r\n        ),\r\n\r\n        # Navigation action server wrapper\r\n        Node(\r\n            package='humanoid_navigation',\r\n            executable='navigation_action_server',\r\n            name='navigation_action_server',\r\n            parameters=[{'use_sim_time': True}],\r\n        ),\r\n    ])\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"action-server",children:"Navigation Action Server"}),"\n",(0,s.jsx)(n.h3,{id:"custom-navigation-interface",children:"Custom Navigation Interface"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"#!/usr/bin/env python3\r\n\"\"\"Navigation action server for humanoid system.\"\"\"\r\n\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom rclpy.action import ActionServer, ActionClient, CancelResponse, GoalResponse\r\nfrom rclpy.callback_groups import ReentrantCallbackGroup\r\nfrom nav2_msgs.action import NavigateToPose\r\nfrom geometry_msgs.msg import PoseStamped\r\nfrom std_msgs.msg import String\r\nimport json\r\n\r\n\r\nclass NavigationActionServer(Node):\r\n    \"\"\"Wrap Nav2 with humanoid-specific interface.\"\"\"\r\n\r\n    def __init__(self):\r\n        super().__init__('navigation_action_server')\r\n\r\n        self.callback_group = ReentrantCallbackGroup()\r\n\r\n        # Nav2 action client\r\n        self.nav2_client = ActionClient(\r\n            self,\r\n            NavigateToPose,\r\n            'navigate_to_pose',\r\n            callback_group=self.callback_group\r\n        )\r\n\r\n        # Custom action server for VLA integration\r\n        self.action_server = ActionServer(\r\n            self,\r\n            NavigateToPose,\r\n            'humanoid/navigate',\r\n            execute_callback=self.execute_callback,\r\n            goal_callback=self.goal_callback,\r\n            cancel_callback=self.cancel_callback,\r\n            callback_group=self.callback_group\r\n        )\r\n\r\n        # Status publisher\r\n        self.status_pub = self.create_publisher(\r\n            String, '/navigation/status', 10\r\n        )\r\n\r\n        # State\r\n        self.current_goal = None\r\n        self.nav2_goal_handle = None\r\n\r\n        self.get_logger().info('Navigation action server ready')\r\n\r\n    def goal_callback(self, goal_request):\r\n        \"\"\"Accept or reject incoming goal.\"\"\"\r\n        self.get_logger().info('Received navigation goal')\r\n\r\n        # Validate goal\r\n        if not self.is_valid_goal(goal_request.pose):\r\n            self.get_logger().warn('Invalid goal rejected')\r\n            return GoalResponse.REJECT\r\n\r\n        return GoalResponse.ACCEPT\r\n\r\n    def cancel_callback(self, goal_handle):\r\n        \"\"\"Handle cancel request.\"\"\"\r\n        self.get_logger().info('Cancel requested')\r\n\r\n        # Cancel Nav2 goal if active\r\n        if self.nav2_goal_handle is not None:\r\n            self.nav2_goal_handle.cancel_goal_async()\r\n\r\n        return CancelResponse.ACCEPT\r\n\r\n    async def execute_callback(self, goal_handle):\r\n        \"\"\"Execute navigation goal.\"\"\"\r\n        self.get_logger().info('Executing navigation goal')\r\n        self.current_goal = goal_handle.request.pose\r\n\r\n        # Wait for Nav2\r\n        if not self.nav2_client.wait_for_server(timeout_sec=5.0):\r\n            self.get_logger().error('Nav2 server not available')\r\n            goal_handle.abort()\r\n            return NavigateToPose.Result()\r\n\r\n        # Send to Nav2\r\n        nav2_goal = NavigateToPose.Goal()\r\n        nav2_goal.pose = goal_handle.request.pose\r\n\r\n        self.publish_status('navigating', 'Starting navigation')\r\n\r\n        # Send goal and wait\r\n        send_goal_future = self.nav2_client.send_goal_async(\r\n            nav2_goal,\r\n            feedback_callback=self.nav2_feedback_callback\r\n        )\r\n\r\n        # Wait for goal acceptance\r\n        self.nav2_goal_handle = await send_goal_future\r\n\r\n        if not self.nav2_goal_handle.accepted:\r\n            self.get_logger().warn('Nav2 rejected goal')\r\n            self.publish_status('failed', 'Goal rejected by planner')\r\n            goal_handle.abort()\r\n            return NavigateToPose.Result()\r\n\r\n        # Wait for result\r\n        result_future = self.nav2_goal_handle.get_result_async()\r\n        result = await result_future\r\n\r\n        # Process result\r\n        if result.status == 4:  # SUCCEEDED\r\n            self.get_logger().info('Navigation succeeded')\r\n            self.publish_status('succeeded', 'Reached goal')\r\n            goal_handle.succeed()\r\n        elif result.status == 5:  # CANCELED\r\n            self.get_logger().info('Navigation canceled')\r\n            self.publish_status('canceled', 'Navigation canceled')\r\n            goal_handle.canceled()\r\n        else:\r\n            self.get_logger().warn(f'Navigation failed with status {result.status}')\r\n            self.publish_status('failed', f'Navigation failed: {result.status}')\r\n            goal_handle.abort()\r\n\r\n        return NavigateToPose.Result()\r\n\r\n    def nav2_feedback_callback(self, feedback_msg):\r\n        \"\"\"Forward Nav2 feedback.\"\"\"\r\n        feedback = feedback_msg.feedback\r\n        distance = feedback.distance_remaining\r\n\r\n        self.publish_status(\r\n            'navigating',\r\n            f'Distance remaining: {distance:.2f}m'\r\n        )\r\n\r\n    def is_valid_goal(self, pose: PoseStamped) -> bool:\r\n        \"\"\"Validate navigation goal.\"\"\"\r\n        # Check bounds\r\n        x, y = pose.pose.position.x, pose.pose.position.y\r\n\r\n        # Workspace limits (should come from params)\r\n        if not (-10 < x < 10 and -10 < y < 10):\r\n            return False\r\n\r\n        return True\r\n\r\n    def publish_status(self, state: str, message: str):\r\n        \"\"\"Publish navigation status.\"\"\"\r\n        status = {\r\n            'state': state,\r\n            'message': message,\r\n            'goal': {\r\n                'x': self.current_goal.pose.position.x if self.current_goal else None,\r\n                'y': self.current_goal.pose.position.y if self.current_goal else None,\r\n            }\r\n        }\r\n        msg = String()\r\n        msg.data = json.dumps(status)\r\n        self.status_pub.publish(msg)\r\n\r\n\r\ndef main():\r\n    rclpy.init()\r\n    node = NavigationActionServer()\r\n    rclpy.spin(node)\r\n    rclpy.shutdown()\r\n\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"obstacle-avoidance",children:"Dynamic Obstacle Avoidance"}),"\n",(0,s.jsx)(n.h3,{id:"obstacle-detection-and-tracking",children:"Obstacle Detection and Tracking"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"#!/usr/bin/env python3\r\n\"\"\"Dynamic obstacle tracking for navigation.\"\"\"\r\n\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom sensor_msgs.msg import LaserScan\r\nfrom visualization_msgs.msg import MarkerArray, Marker\r\nfrom geometry_msgs.msg import Point\r\nimport numpy as np\r\nfrom sklearn.cluster import DBSCAN\r\n\r\n\r\nclass ObstacleTracker(Node):\r\n    \"\"\"Track and predict dynamic obstacles.\"\"\"\r\n\r\n    def __init__(self):\r\n        super().__init__('obstacle_tracker')\r\n\r\n        # Tracking state\r\n        self.tracked_obstacles = {}\r\n        self.next_id = 0\r\n\r\n        # Parameters\r\n        self.cluster_eps = 0.3  # DBSCAN epsilon\r\n        self.cluster_min_samples = 5\r\n        self.max_tracking_distance = 0.5\r\n        self.prediction_horizon = 1.0  # seconds\r\n\r\n        # Subscribers\r\n        self.scan_sub = self.create_subscription(\r\n            LaserScan, '/scan', self.scan_callback, 10\r\n        )\r\n\r\n        # Publishers\r\n        self.marker_pub = self.create_publisher(\r\n            MarkerArray, '/obstacles/markers', 10\r\n        )\r\n\r\n        # Timer for obstacle prediction\r\n        self.create_timer(0.1, self.predict_callback)\r\n\r\n    def scan_callback(self, msg: LaserScan):\r\n        \"\"\"Process laser scan for obstacles.\"\"\"\r\n        # Convert to Cartesian points\r\n        points = self.scan_to_points(msg)\r\n\r\n        if len(points) < self.cluster_min_samples:\r\n            return\r\n\r\n        # Cluster points\r\n        clusters = self.cluster_points(points)\r\n\r\n        # Update tracking\r\n        self.update_tracking(clusters)\r\n\r\n        # Publish visualization\r\n        self.publish_markers()\r\n\r\n    def scan_to_points(self, scan: LaserScan) -> np.ndarray:\r\n        \"\"\"Convert laser scan to 2D points.\"\"\"\r\n        angles = np.arange(\r\n            scan.angle_min,\r\n            scan.angle_max,\r\n            scan.angle_increment\r\n        )\r\n\r\n        ranges = np.array(scan.ranges)\r\n\r\n        # Filter invalid ranges\r\n        valid = (ranges > scan.range_min) & (ranges < scan.range_max)\r\n        angles = angles[valid]\r\n        ranges = ranges[valid]\r\n\r\n        # Convert to Cartesian\r\n        x = ranges * np.cos(angles)\r\n        y = ranges * np.sin(angles)\r\n\r\n        return np.column_stack([x, y])\r\n\r\n    def cluster_points(self, points: np.ndarray) -> list:\r\n        \"\"\"Cluster points into obstacles.\"\"\"\r\n        clustering = DBSCAN(\r\n            eps=self.cluster_eps,\r\n            min_samples=self.cluster_min_samples\r\n        ).fit(points)\r\n\r\n        clusters = []\r\n        for label in set(clustering.labels_):\r\n            if label == -1:  # Noise\r\n                continue\r\n\r\n            cluster_points = points[clustering.labels_ == label]\r\n            centroid = np.mean(cluster_points, axis=0)\r\n            radius = np.max(np.linalg.norm(cluster_points - centroid, axis=1))\r\n\r\n            clusters.append({\r\n                'centroid': centroid,\r\n                'radius': radius,\r\n                'points': cluster_points\r\n            })\r\n\r\n        return clusters\r\n\r\n    def update_tracking(self, clusters: list):\r\n        \"\"\"Update obstacle tracking with new detections.\"\"\"\r\n        current_time = self.get_clock().now()\r\n\r\n        # Match clusters to tracked obstacles\r\n        matched = set()\r\n\r\n        for cluster in clusters:\r\n            centroid = cluster['centroid']\r\n            best_match = None\r\n            best_distance = self.max_tracking_distance\r\n\r\n            for obs_id, obs in self.tracked_obstacles.items():\r\n                distance = np.linalg.norm(centroid - obs['position'])\r\n                if distance < best_distance:\r\n                    best_match = obs_id\r\n                    best_distance = distance\r\n\r\n            if best_match is not None:\r\n                # Update existing obstacle\r\n                obs = self.tracked_obstacles[best_match]\r\n                dt = (current_time - obs['last_seen']).nanoseconds / 1e9\r\n\r\n                # Calculate velocity\r\n                if dt > 0:\r\n                    velocity = (centroid - obs['position']) / dt\r\n                    # Exponential smoothing\r\n                    obs['velocity'] = 0.7 * obs['velocity'] + 0.3 * velocity\r\n\r\n                obs['position'] = centroid\r\n                obs['radius'] = cluster['radius']\r\n                obs['last_seen'] = current_time\r\n                matched.add(best_match)\r\n\r\n            else:\r\n                # New obstacle\r\n                self.tracked_obstacles[self.next_id] = {\r\n                    'position': centroid,\r\n                    'velocity': np.zeros(2),\r\n                    'radius': cluster['radius'],\r\n                    'last_seen': current_time\r\n                }\r\n                self.next_id += 1\r\n\r\n        # Remove stale obstacles\r\n        stale_threshold = 1.0  # seconds\r\n        stale_ids = []\r\n        for obs_id, obs in self.tracked_obstacles.items():\r\n            age = (current_time - obs['last_seen']).nanoseconds / 1e9\r\n            if age > stale_threshold:\r\n                stale_ids.append(obs_id)\r\n\r\n        for obs_id in stale_ids:\r\n            del self.tracked_obstacles[obs_id]\r\n\r\n    def predict_callback(self):\r\n        \"\"\"Predict future obstacle positions.\"\"\"\r\n        for obs_id, obs in self.tracked_obstacles.items():\r\n            # Predict position at horizon\r\n            predicted = obs['position'] + obs['velocity'] * self.prediction_horizon\r\n            obs['predicted_position'] = predicted\r\n\r\n    def publish_markers(self):\r\n        \"\"\"Publish obstacle visualization.\"\"\"\r\n        marker_array = MarkerArray()\r\n\r\n        for obs_id, obs in self.tracked_obstacles.items():\r\n            # Current position marker\r\n            marker = Marker()\r\n            marker.header.frame_id = 'base_link'\r\n            marker.header.stamp = self.get_clock().now().to_msg()\r\n            marker.ns = 'obstacles'\r\n            marker.id = obs_id\r\n            marker.type = Marker.CYLINDER\r\n            marker.action = Marker.ADD\r\n            marker.pose.position.x = obs['position'][0]\r\n            marker.pose.position.y = obs['position'][1]\r\n            marker.pose.position.z = 0.5\r\n            marker.scale.x = obs['radius'] * 2\r\n            marker.scale.y = obs['radius'] * 2\r\n            marker.scale.z = 1.0\r\n            marker.color.r = 1.0\r\n            marker.color.a = 0.5\r\n            marker_array.markers.append(marker)\r\n\r\n            # Velocity vector marker\r\n            if np.linalg.norm(obs['velocity']) > 0.1:\r\n                vel_marker = Marker()\r\n                vel_marker.header = marker.header\r\n                vel_marker.ns = 'velocities'\r\n                vel_marker.id = obs_id\r\n                vel_marker.type = Marker.ARROW\r\n                vel_marker.action = Marker.ADD\r\n\r\n                start = Point()\r\n                start.x = obs['position'][0]\r\n                start.y = obs['position'][1]\r\n                start.z = 0.5\r\n\r\n                end = Point()\r\n                end.x = obs['position'][0] + obs['velocity'][0]\r\n                end.y = obs['position'][1] + obs['velocity'][1]\r\n                end.z = 0.5\r\n\r\n                vel_marker.points = [start, end]\r\n                vel_marker.scale.x = 0.05\r\n                vel_marker.scale.y = 0.1\r\n                vel_marker.color.g = 1.0\r\n                vel_marker.color.a = 0.8\r\n                marker_array.markers.append(vel_marker)\r\n\r\n        self.marker_pub.publish(marker_array)\r\n\r\n\r\ndef main():\r\n    rclpy.init()\r\n    node = ObstacleTracker()\r\n    rclpy.spin(node)\r\n    rclpy.shutdown()\r\n\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"recovery",children:"Navigation Recovery Behaviors"}),"\n",(0,s.jsx)(n.h3,{id:"recovery-behavior-implementation",children:"Recovery Behavior Implementation"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'#!/usr/bin/env python3\r\n"""Navigation recovery behaviors."""\r\n\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom geometry_msgs.msg import Twist\r\nfrom nav_msgs.msg import Odometry\r\nimport numpy as np\r\nimport time\r\n\r\n\r\nclass NavigationRecovery(Node):\r\n    """Implement navigation recovery behaviors."""\r\n\r\n    def __init__(self):\r\n        super().__init__(\'navigation_recovery\')\r\n\r\n        self.cmd_vel_pub = self.create_publisher(Twist, \'/cmd_vel\', 10)\r\n\r\n        self.odom_sub = self.create_subscription(\r\n            Odometry, \'/odom\', self.odom_callback, 10\r\n        )\r\n\r\n        self.current_pose = None\r\n\r\n    def odom_callback(self, msg: Odometry):\r\n        """Track current pose."""\r\n        self.current_pose = msg.pose.pose\r\n\r\n    def spin_recovery(self, angle: float = 2 * np.pi, angular_speed: float = 0.5):\r\n        """Rotate in place to clear costmap."""\r\n        self.get_logger().info(f\'Executing spin recovery: {np.degrees(angle):.0f} degrees\')\r\n\r\n        duration = abs(angle / angular_speed)\r\n        direction = 1 if angle > 0 else -1\r\n\r\n        twist = Twist()\r\n        twist.angular.z = direction * angular_speed\r\n\r\n        start_time = time.time()\r\n        rate = self.create_rate(20)\r\n\r\n        while time.time() - start_time < duration:\r\n            self.cmd_vel_pub.publish(twist)\r\n            rate.sleep()\r\n\r\n        # Stop\r\n        self.cmd_vel_pub.publish(Twist())\r\n        self.get_logger().info(\'Spin recovery complete\')\r\n\r\n    def back_up_recovery(self, distance: float = 0.3, speed: float = 0.1):\r\n        """Back up to clear obstacle."""\r\n        self.get_logger().info(f\'Executing backup recovery: {distance:.2f}m\')\r\n\r\n        duration = distance / speed\r\n\r\n        twist = Twist()\r\n        twist.linear.x = -speed\r\n\r\n        start_time = time.time()\r\n        rate = self.create_rate(20)\r\n\r\n        while time.time() - start_time < duration:\r\n            self.cmd_vel_pub.publish(twist)\r\n            rate.sleep()\r\n\r\n        # Stop\r\n        self.cmd_vel_pub.publish(Twist())\r\n        self.get_logger().info(\'Backup recovery complete\')\r\n\r\n    def wait_recovery(self, duration: float = 5.0):\r\n        """Wait for dynamic obstacle to clear."""\r\n        self.get_logger().info(f\'Waiting for obstacle to clear: {duration:.1f}s\')\r\n\r\n        # Stop and wait\r\n        self.cmd_vel_pub.publish(Twist())\r\n        time.sleep(duration)\r\n\r\n        self.get_logger().info(\'Wait recovery complete\')\r\n\r\n    def execute_recovery_sequence(self):\r\n        """Execute standard recovery sequence."""\r\n        self.get_logger().info(\'Starting recovery sequence\')\r\n\r\n        # 1. Wait briefly\r\n        self.wait_recovery(2.0)\r\n\r\n        # 2. Spin to update costmap\r\n        self.spin_recovery(np.pi)\r\n\r\n        # 3. If still stuck, back up\r\n        # (Would check if still blocked here)\r\n        self.back_up_recovery(0.3)\r\n\r\n        # 4. Spin again\r\n        self.spin_recovery(-np.pi / 2)\r\n\r\n        self.get_logger().info(\'Recovery sequence complete\')\n'})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,s.jsx)(n.p,{children:"This chapter covered navigation system implementation:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"VSLAM configuration"})," with Isaac ROS for robust visual-inertial localization."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Nav2 setup"})," with tuned parameters for costmap, planner, and controller."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Custom action server"})," wrapping Nav2 for VLA integration."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Dynamic obstacle tracking"})," using clustering and velocity estimation."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Recovery behaviors"})," for handling navigation failures."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"navigation-checklist",children:"Navigation Checklist"}),"\n",(0,s.jsx)(n.p,{children:"Before proceeding, verify:"}),"\n",(0,s.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","VSLAM produces stable odometry"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Costmaps update with LiDAR data"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Global planner generates valid paths"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Local planner follows paths smoothly"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Obstacle avoidance prevents collisions"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Recovery behaviors execute when stuck"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"whats-next",children:"What's Next"}),"\n",(0,s.jsxs)(n.p,{children:["In ",(0,s.jsx)(n.a,{href:"/capstone/chapter-4-manipulation",children:"Chapter 4: Manipulation System"}),", you'll implement dual-arm manipulation with MoveIt 2 for pick and place operations."]})]})}function _(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);