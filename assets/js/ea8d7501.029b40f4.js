"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[4452],{8453(e,n,r){r.d(n,{R:()=>t,x:()=>l});var s=r(6540);const i={},a=s.createContext(i);function t(e){const n=s.useContext(a);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:t(e.components),s.createElement(a.Provider,{value:n},e.children)}},9376(e,n,r){r.r(n),r.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>h,frontMatter:()=>t,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"module-3/chapter-3-simulated-sensors","title":"Chapter 3: Simulated Sensors","description":"Chapter Goal","source":"@site/docs/module-3/chapter-3-simulated-sensors.md","sourceDirName":"module-3","slug":"/module-3/chapter-3-simulated-sensors","permalink":"/Master-Robotics-AI/textbook/module-3/chapter-3-simulated-sensors","draft":false,"unlisted":false,"editUrl":"https://github.com/HasnainCodeHub/Master-Robotics-AI/tree/main/docs/docs/module-3/chapter-3-simulated-sensors.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"id":"chapter-3-simulated-sensors","title":"Chapter 3: Simulated Sensors","sidebar_label":"3. Simulated Sensors","sidebar_position":4},"sidebar":"textbookSidebar","previous":{"title":"2. Gazebo World Building","permalink":"/Master-Robotics-AI/textbook/module-3/chapter-2-gazebo-world-building"},"next":{"title":"4. Simulated Actuators","permalink":"/Master-Robotics-AI/textbook/module-3/chapter-4-simulated-actuators"}}');var i=r(4848),a=r(8453);const t={id:"chapter-3-simulated-sensors",title:"Chapter 3: Simulated Sensors",sidebar_label:"3. Simulated Sensors",sidebar_position:4},l="Chapter 3: Simulated Sensors with Realistic Noise Models",d={},c=[{value:"Chapter Goal",id:"chapter-goal",level:2},{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Why Sensor Noise Matters",id:"why-sensor-noise-matters",level:2},{value:"Camera Simulation",id:"camera",level:2},{value:"Basic Camera Configuration",id:"basic-camera-configuration",level:3},{value:"Matching Real Camera Specifications",id:"matching-real-camera-specifications",level:3},{value:"Adding Camera Noise",id:"adding-camera-noise",level:3},{value:"Camera Intrinsics",id:"camera-intrinsics",level:3},{value:"LiDAR Simulation",id:"lidar",level:2},{value:"GPU LiDAR Configuration",id:"gpu-lidar-configuration",level:3},{value:"Matching Real LiDAR Specifications",id:"matching-real-lidar-specifications",level:3},{value:"LiDAR Noise Models",id:"lidar-noise-models",level:3},{value:"Reality Gap Warning",id:"reality-gap-warning",level:3},{value:"IMU Simulation",id:"imu",level:2},{value:"Basic IMU Configuration",id:"basic-imu-configuration",level:3},{value:"Matching Real IMU Specifications",id:"matching-real-imu-specifications",level:3},{value:"IMU Bias and Drift",id:"imu-bias-and-drift",level:3},{value:"Depth Camera Simulation",id:"depth-camera",level:2},{value:"RGBD Camera Configuration",id:"rgbd-camera-configuration",level:3},{value:"Depth Noise Characteristics",id:"depth-noise-characteristics",level:3},{value:"ROS 2 Bridge Configuration",id:"ros-bridge",level:2},{value:"Bridge Launch File",id:"bridge-launch-file",level:3},{value:"Verifying Sensor Output",id:"verifying-sensor-output",level:3},{value:"Validating Sensor Statistics",id:"validation",level:2},{value:"IMU Noise Validation",id:"imu-noise-validation",level:3},{value:"Summary",id:"summary",level:2},{value:"Reality Gap Callout",id:"reality-gap-callout",level:2},{value:"Self-Assessment Questions",id:"self-assessment-questions",level:2},{value:"What&#39;s Next",id:"whats-next",level:2}];function o(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"chapter-3-simulated-sensors-with-realistic-noise-models",children:"Chapter 3: Simulated Sensors with Realistic Noise Models"})}),"\n",(0,i.jsx)(n.h2,{id:"chapter-goal",children:"Chapter Goal"}),"\n",(0,i.jsxs)(n.p,{children:["By the end of this chapter, you will be able to ",(0,i.jsx)(n.strong,{children:"configure simulated sensors (cameras, LiDAR, IMU, depth cameras) with noise models that match the physical sensor specifications learned in Module 1"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,i.jsx)(n.p,{children:"After completing this chapter, you will be able to:"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"ID"}),(0,i.jsx)(n.th,{children:"Objective"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"3.1"}),(0,i.jsx)(n.td,{children:"Configure a simulated camera with resolution, frame rate, and field of view matching a target sensor"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"3.2"}),(0,i.jsx)(n.td,{children:"Add Gaussian noise to camera images modeling realistic sensor noise"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"3.3"}),(0,i.jsx)(n.td,{children:"Configure simulated LiDAR with range, angular resolution, and noise"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"3.4"}),(0,i.jsx)(n.td,{children:"Configure simulated IMU with bias, drift, and Gaussian noise"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"3.5"}),(0,i.jsx)(n.td,{children:"Validate that simulated sensor output statistics match expected behavior"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"3.6"}),(0,i.jsx)(n.td,{children:"Connect simulated sensors to ROS 2 topics via ros_gz bridge"})]})]})]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"why-sensor-noise-matters",children:"Why Sensor Noise Matters"}),"\n",(0,i.jsx)(n.p,{children:"Consider this scenario: Your object detection algorithm achieves 99% accuracy on clean simulated images. On real hardware with sensor noise, accuracy drops to 75%."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"The algorithm never learned to handle noise."})}),"\n",(0,i.jsx)(n.p,{children:"Adding realistic noise to simulated sensors:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Trains perception algorithms to be robust"}),"\n",(0,i.jsx)(n.li,{children:"Reveals algorithm weaknesses before deployment"}),"\n",(0,i.jsx)(n.li,{children:"Creates more representative test conditions"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Physical Grounding"}),": This chapter directly applies the sensor analysis from Module 1, Chapter 2. You'll configure noise parameters that match real sensor datasheets."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"camera",children:"Camera Simulation"}),"\n",(0,i.jsx)(n.h3,{id:"basic-camera-configuration",children:"Basic Camera Configuration"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-xml",children:'<model name="camera">\r\n  <pose>0 0 0.5 0 0 0</pose>\r\n  <link name="camera_link">\r\n    <sensor name="camera_sensor" type="camera">\r\n      <always_on>true</always_on>\r\n      <update_rate>30.0</update_rate>\r\n\r\n      <camera>\r\n        \x3c!-- Resolution --\x3e\r\n        <horizontal_fov>1.047</horizontal_fov>  \x3c!-- 60 degrees --\x3e\r\n        <image>\r\n          <width>640</width>\r\n          <height>480</height>\r\n          <format>R8G8B8</format>\r\n        </image>\r\n\r\n        \x3c!-- Depth range --\x3e\r\n        <clip>\r\n          <near>0.1</near>\r\n          <far>100</far>\r\n        </clip>\r\n\r\n        \x3c!-- Distortion (optional) --\x3e\r\n        <distortion>\r\n          <k1>0.0</k1>\r\n          <k2>0.0</k2>\r\n          <k3>0.0</k3>\r\n          <p1>0.0</p1>\r\n          <p2>0.0</p2>\r\n          <center>0.5 0.5</center>\r\n        </distortion>\r\n      </camera>\r\n\r\n      \x3c!-- ros_gz bridge topic --\x3e\r\n      <topic>/camera/image_raw</topic>\r\n    </sensor>\r\n  </link>\r\n</model>\n'})}),"\n",(0,i.jsx)(n.h3,{id:"matching-real-camera-specifications",children:"Matching Real Camera Specifications"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Example: Intel RealSense D435"})}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Parameter"}),(0,i.jsx)(n.th,{children:"Real Spec"}),(0,i.jsx)(n.th,{children:"SDF Configuration"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"RGB Resolution"}),(0,i.jsx)(n.td,{children:"1920x1080"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"<width>1920</width><height>1080</height>"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Frame Rate"}),(0,i.jsx)(n.td,{children:"30 fps"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"<update_rate>30.0</update_rate>"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Horizontal FOV"}),(0,i.jsx)(n.td,{children:"69\xb0"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"<horizontal_fov>1.204</horizontal_fov>"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Depth Range"}),(0,i.jsx)(n.td,{children:"0.1-10m"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"<near>0.1</near><far>10</far>"})})]})]})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-xml",children:"\x3c!-- Intel RealSense D435 configuration --\x3e\r\n<camera>\r\n  <horizontal_fov>1.204</horizontal_fov>  \x3c!-- 69 degrees --\x3e\r\n  <image>\r\n    <width>1920</width>\r\n    <height>1080</height>\r\n    <format>R8G8B8</format>\r\n  </image>\r\n  <clip>\r\n    <near>0.1</near>\r\n    <far>10.0</far>\r\n  </clip>\r\n</camera>\n"})}),"\n",(0,i.jsx)(n.h3,{id:"adding-camera-noise",children:"Adding Camera Noise"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-xml",children:'<sensor name="noisy_camera" type="camera">\r\n  <camera>\r\n    <image>\r\n      <width>640</width>\r\n      <height>480</height>\r\n    </image>\r\n\r\n    \x3c!-- Gaussian noise --\x3e\r\n    <noise>\r\n      <type>gaussian</type>\r\n      <mean>0.0</mean>\r\n      <stddev>0.007</stddev>  \x3c!-- Based on sensor SNR --\x3e\r\n    </noise>\r\n  </camera>\r\n</sensor>\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Physical Grounding"}),": Noise stddev relates to sensor Signal-to-Noise Ratio (SNR):"]}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"SNR (dB)"}),(0,i.jsx)(n.th,{children:"Noise StdDev"}),(0,i.jsx)(n.th,{children:"Visual Effect"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"40"}),(0,i.jsx)(n.td,{children:"0.01"}),(0,i.jsx)(n.td,{children:"Barely visible"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"30"}),(0,i.jsx)(n.td,{children:"0.03"}),(0,i.jsx)(n.td,{children:"Light grain"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"20"}),(0,i.jsx)(n.td,{children:"0.1"}),(0,i.jsx)(n.td,{children:"Obvious noise"})]})]})]}),"\n",(0,i.jsx)(n.h3,{id:"camera-intrinsics",children:"Camera Intrinsics"}),"\n",(0,i.jsx)(n.p,{children:"For perception algorithms requiring calibration:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-xml",children:"<camera>\r\n  <lens>\r\n    <intrinsics>\r\n      <fx>554.25</fx>    \x3c!-- Focal length X (pixels) --\x3e\r\n      <fy>554.25</fy>    \x3c!-- Focal length Y (pixels) --\x3e\r\n      <cx>320.0</cx>     \x3c!-- Principal point X --\x3e\r\n      <cy>240.0</cy>     \x3c!-- Principal point Y --\x3e\r\n      <s>0</s>           \x3c!-- Skew --\x3e\r\n    </intrinsics>\r\n  </lens>\r\n</camera>\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"lidar",children:"LiDAR Simulation"}),"\n",(0,i.jsx)(n.h3,{id:"gpu-lidar-configuration",children:"GPU LiDAR Configuration"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-xml",children:'<model name="lidar">\r\n  <link name="lidar_link">\r\n    <sensor name="gpu_lidar" type="gpu_lidar">\r\n      <always_on>true</always_on>\r\n      <update_rate>10.0</update_rate>\r\n\r\n      <lidar>\r\n        \x3c!-- Horizontal scan --\x3e\r\n        <scan>\r\n          <horizontal>\r\n            <samples>360</samples>\r\n            <resolution>1</resolution>\r\n            <min_angle>-3.14159</min_angle>\r\n            <max_angle>3.14159</max_angle>\r\n          </horizontal>\r\n          <vertical>\r\n            <samples>1</samples>\r\n            <resolution>1</resolution>\r\n            <min_angle>0</min_angle>\r\n            <max_angle>0</max_angle>\r\n          </vertical>\r\n        </scan>\r\n\r\n        \x3c!-- Range --\x3e\r\n        <range>\r\n          <min>0.1</min>\r\n          <max>30.0</max>\r\n          <resolution>0.01</resolution>\r\n        </range>\r\n      </lidar>\r\n\r\n      <topic>/scan</topic>\r\n    </sensor>\r\n  </link>\r\n</model>\n'})}),"\n",(0,i.jsx)(n.h3,{id:"matching-real-lidar-specifications",children:"Matching Real LiDAR Specifications"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Example: Velodyne VLP-16"})}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Parameter"}),(0,i.jsx)(n.th,{children:"Real Spec"}),(0,i.jsx)(n.th,{children:"SDF Configuration"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Horizontal FOV"}),(0,i.jsx)(n.td,{children:"360\xb0"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"min_angle=-3.14159, max_angle=3.14159"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Horizontal Resolution"}),(0,i.jsx)(n.td,{children:"0.1\xb0-0.4\xb0"}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.code,{children:"samples=900"})," for 0.4\xb0"]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Vertical Channels"}),(0,i.jsx)(n.td,{children:"16"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"vertical/samples=16"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Vertical FOV"}),(0,i.jsx)(n.td,{children:"\xb115\xb0"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"min=-0.2618, max=0.2618"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Range"}),(0,i.jsx)(n.td,{children:"100m"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"<max>100.0</max>"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Update Rate"}),(0,i.jsx)(n.td,{children:"5-20 Hz"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"<update_rate>10.0</update_rate>"})})]})]})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-xml",children:"\x3c!-- Velodyne VLP-16 configuration --\x3e\r\n<lidar>\r\n  <scan>\r\n    <horizontal>\r\n      <samples>900</samples>\r\n      <min_angle>-3.14159</min_angle>\r\n      <max_angle>3.14159</max_angle>\r\n    </horizontal>\r\n    <vertical>\r\n      <samples>16</samples>\r\n      <min_angle>-0.2618</min_angle>  \x3c!-- -15 degrees --\x3e\r\n      <max_angle>0.2618</max_angle>   \x3c!-- +15 degrees --\x3e\r\n    </vertical>\r\n  </scan>\r\n  <range>\r\n    <min>0.5</min>\r\n    <max>100.0</max>\r\n    <resolution>0.003</resolution>  \x3c!-- 3mm --\x3e\r\n  </range>\r\n</lidar>\n"})}),"\n",(0,i.jsx)(n.h3,{id:"lidar-noise-models",children:"LiDAR Noise Models"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-xml",children:"<lidar>\r\n  <noise>\r\n    <type>gaussian</type>\r\n    <mean>0.0</mean>\r\n    <stddev>0.02</stddev>  \x3c!-- 2cm range noise --\x3e\r\n  </noise>\r\n</lidar>\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Physical Grounding"})," from Module 1:"]}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"LiDAR Type"}),(0,i.jsx)(n.th,{children:"Typical Range Noise"}),(0,i.jsx)(n.th,{children:"Dropout Rate"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Time-of-Flight"}),(0,i.jsx)(n.td,{children:"1-3 cm"}),(0,i.jsx)(n.td,{children:"Low"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Triangulation"}),(0,i.jsx)(n.td,{children:"0.5-2 cm"}),(0,i.jsx)(n.td,{children:"Moderate"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Solid State"}),(0,i.jsx)(n.td,{children:"2-5 cm"}),(0,i.jsx)(n.td,{children:"Varies"})]})]})]}),"\n",(0,i.jsx)(n.h3,{id:"reality-gap-warning",children:"Reality Gap Warning"}),"\n",(0,i.jsx)(n.p,{children:"Simulated LiDAR uses ray-casting, which differs from real time-of-flight:"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Aspect"}),(0,i.jsx)(n.th,{children:"Simulation"}),(0,i.jsx)(n.th,{children:"Reality"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Multi-path reflections"}),(0,i.jsx)(n.td,{children:"Not modeled"}),(0,i.jsx)(n.td,{children:"Can cause ghost points"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Translucent materials"}),(0,i.jsx)(n.td,{children:"Solid"}),(0,i.jsx)(n.td,{children:"Partial penetration"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Retroreflective surfaces"}),(0,i.jsx)(n.td,{children:"Normal"}),(0,i.jsx)(n.td,{children:"Very bright returns"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Motion blur"}),(0,i.jsx)(n.td,{children:"Instantaneous"}),(0,i.jsx)(n.td,{children:"Distortion during motion"})]})]})]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"imu",children:"IMU Simulation"}),"\n",(0,i.jsx)(n.h3,{id:"basic-imu-configuration",children:"Basic IMU Configuration"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-xml",children:'<model name="imu_model">\r\n  <link name="imu_link">\r\n    <sensor name="imu_sensor" type="imu">\r\n      <always_on>true</always_on>\r\n      <update_rate>100.0</update_rate>\r\n\r\n      <imu>\r\n        <angular_velocity>\r\n          <x>\r\n            <noise type="gaussian">\r\n              <mean>0.0</mean>\r\n              <stddev>0.001</stddev>  \x3c!-- rad/s --\x3e\r\n            </noise>\r\n          </x>\r\n          <y>\r\n            <noise type="gaussian">\r\n              <mean>0.0</mean>\r\n              <stddev>0.001</stddev>\r\n            </noise>\r\n          </y>\r\n          <z>\r\n            <noise type="gaussian">\r\n              <mean>0.0</mean>\r\n              <stddev>0.001</stddev>\r\n            </noise>\r\n          </z>\r\n        </angular_velocity>\r\n\r\n        <linear_acceleration>\r\n          <x>\r\n            <noise type="gaussian">\r\n              <mean>0.0</mean>\r\n              <stddev>0.01</stddev>  \x3c!-- m/s\xb2 --\x3e\r\n            </noise>\r\n          </x>\r\n          <y>\r\n            <noise type="gaussian">\r\n              <mean>0.0</mean>\r\n              <stddev>0.01</stddev>\r\n            </noise>\r\n          </y>\r\n          <z>\r\n            <noise type="gaussian">\r\n              <mean>0.0</mean>\r\n              <stddev>0.01</stddev>\r\n            </noise>\r\n          </z>\r\n        </linear_acceleration>\r\n      </imu>\r\n\r\n      <topic>/imu/data</topic>\r\n    </sensor>\r\n  </link>\r\n</model>\n'})}),"\n",(0,i.jsx)(n.h3,{id:"matching-real-imu-specifications",children:"Matching Real IMU Specifications"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Example: InvenSense MPU-6050"})}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Parameter"}),(0,i.jsx)(n.th,{children:"Datasheet Value"}),(0,i.jsx)(n.th,{children:"SDF Conversion"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Gyro Noise Density"}),(0,i.jsx)(n.td,{children:"0.005 \xb0/s/\u221aHz"}),(0,i.jsx)(n.td,{children:"At 100Hz: 0.005 \xd7 \u221a100 = 0.05 \xb0/s = 0.00087 rad/s"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Accel Noise Density"}),(0,i.jsx)(n.td,{children:"400 \xb5g/\u221aHz"}),(0,i.jsx)(n.td,{children:"At 100Hz: 400 \xd7 \u221a100 \xd7 9.81e-6 = 0.039 m/s\xb2"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Gyro Bias Stability"}),(0,i.jsx)(n.td,{children:"5 \xb0/hr"}),(0,i.jsx)(n.td,{children:"Very small, often ignored in short tests"})]})]})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-xml",children:'\x3c!-- MPU-6050 noise parameters --\x3e\r\n<imu>\r\n  <angular_velocity>\r\n    <x><noise type="gaussian"><stddev>0.00087</stddev></noise></x>\r\n    <y><noise type="gaussian"><stddev>0.00087</stddev></noise></y>\r\n    <z><noise type="gaussian"><stddev>0.00087</stddev></noise></z>\r\n  </angular_velocity>\r\n  <linear_acceleration>\r\n    <x><noise type="gaussian"><stddev>0.039</stddev></noise></x>\r\n    <y><noise type="gaussian"><stddev>0.039</stddev></noise></y>\r\n    <z><noise type="gaussian"><stddev>0.039</stddev></noise></z>\r\n  </linear_acceleration>\r\n</imu>\n'})}),"\n",(0,i.jsx)(n.h3,{id:"imu-bias-and-drift",children:"IMU Bias and Drift"}),"\n",(0,i.jsx)(n.p,{children:"Real IMUs have bias that drifts over time. Simulation can approximate this:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-xml",children:'<angular_velocity>\r\n  <x>\r\n    <noise type="gaussian">\r\n      <mean>0.0001</mean>   \x3c!-- Constant bias --\x3e\r\n      <stddev>0.001</stddev> \x3c!-- Random noise --\x3e\r\n      <bias_mean>0.0001</bias_mean>\r\n      <bias_stddev>0.00001</bias_stddev>  \x3c!-- Bias drift --\x3e\r\n    </noise>\r\n  </x>\r\n</angular_velocity>\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Physical Grounding"}),": IMU bias causes position drift when integrated:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"0.1 \xb0/s gyro bias \u2192 ~6\xb0/minute heading error"}),"\n",(0,i.jsx)(n.li,{children:"0.01 m/s\xb2 accel bias \u2192 ~18m/minute position error"}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"depth-camera",children:"Depth Camera Simulation"}),"\n",(0,i.jsx)(n.h3,{id:"rgbd-camera-configuration",children:"RGBD Camera Configuration"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-xml",children:'<sensor name="rgbd_camera" type="rgbd_camera">\r\n  <always_on>true</always_on>\r\n  <update_rate>30.0</update_rate>\r\n\r\n  <camera>\r\n    <horizontal_fov>1.047</horizontal_fov>\r\n    <image>\r\n      <width>640</width>\r\n      <height>480</height>\r\n    </image>\r\n    <clip>\r\n      <near>0.1</near>\r\n      <far>10.0</far>\r\n    </clip>\r\n\r\n    \x3c!-- Depth noise --\x3e\r\n    <noise>\r\n      <type>gaussian</type>\r\n      <mean>0.0</mean>\r\n      <stddev>0.005</stddev>  \x3c!-- 5mm depth noise --\x3e\r\n    </noise>\r\n  </camera>\r\n\r\n  <topic>/camera/color/image_raw</topic>\r\n  <depth_camera>\r\n    <topic>/camera/depth/image_raw</topic>\r\n  </depth_camera>\r\n</sensor>\n'})}),"\n",(0,i.jsx)(n.h3,{id:"depth-noise-characteristics",children:"Depth Noise Characteristics"}),"\n",(0,i.jsx)(n.p,{children:"Real depth cameras have distance-dependent noise:"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Distance"}),(0,i.jsx)(n.th,{children:"Typical Noise"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"0.5m"}),(0,i.jsx)(n.td,{children:"1-2 mm"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"2m"}),(0,i.jsx)(n.td,{children:"5-10 mm"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"5m"}),(0,i.jsx)(n.td,{children:"20-50 mm"})]})]})]}),"\n",(0,i.jsx)(n.p,{children:"Gazebo's Gaussian noise is distance-independent. For more realistic simulation:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-xml",children:"\x3c!-- Approximate distance-dependent noise with higher base noise --\x3e\r\n<noise>\r\n  <type>gaussian</type>\r\n  <stddev>0.01</stddev>  \x3c!-- 1cm, acceptable for mid-range --\x3e\r\n</noise>\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"ros-bridge",children:"ROS 2 Bridge Configuration"}),"\n",(0,i.jsx)(n.h3,{id:"bridge-launch-file",children:"Bridge Launch File"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# launch/sensor_bridge.launch.py\r\nfrom launch import LaunchDescription\r\nfrom launch_ros.actions import Node\r\n\r\ndef generate_launch_description():\r\n    return LaunchDescription([\r\n        Node(\r\n            package='ros_gz_bridge',\r\n            executable='parameter_bridge',\r\n            arguments=[\r\n                # Camera\r\n                '/camera/image_raw@sensor_msgs/msg/Image[gz.msgs.Image',\r\n                '/camera/camera_info@sensor_msgs/msg/CameraInfo[gz.msgs.CameraInfo',\r\n\r\n                # LiDAR\r\n                '/scan@sensor_msgs/msg/LaserScan[gz.msgs.LaserScan',\r\n\r\n                # IMU\r\n                '/imu/data@sensor_msgs/msg/Imu[gz.msgs.IMU',\r\n\r\n                # Depth camera\r\n                '/camera/depth/image_raw@sensor_msgs/msg/Image[gz.msgs.Image',\r\n\r\n                # Clock\r\n                '/clock@rosgraph_msgs/msg/Clock[gz.msgs.Clock',\r\n            ],\r\n            output='screen'\r\n        ),\r\n    ])\n"})}),"\n",(0,i.jsx)(n.h3,{id:"verifying-sensor-output",children:"Verifying Sensor Output"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"# Check camera topic\r\nros2 topic hz /camera/image_raw\r\nros2 topic echo /camera/image_raw --once\r\n\r\n# Check LiDAR\r\nros2 topic hz /scan\r\nros2 run tf2_ros tf2_echo base_link lidar_link\r\n\r\n# Check IMU\r\nros2 topic hz /imu/data\r\nros2 topic echo /imu/data\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"validation",children:"Validating Sensor Statistics"}),"\n",(0,i.jsx)(n.h3,{id:"imu-noise-validation",children:"IMU Noise Validation"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"#!/usr/bin/env python3\r\n\"\"\"Validate IMU noise matches expected parameters.\"\"\"\r\n\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom sensor_msgs.msg import Imu\r\nimport numpy as np\r\n\r\n\r\nclass ImuValidator(Node):\r\n    def __init__(self):\r\n        super().__init__('imu_validator')\r\n\r\n        self.accel_samples = []\r\n        self.gyro_samples = []\r\n\r\n        self.subscription = self.create_subscription(\r\n            Imu,\r\n            '/imu/data',\r\n            self.imu_callback,\r\n            10\r\n        )\r\n\r\n        # Report every 5 seconds\r\n        self.timer = self.create_timer(5.0, self.report_stats)\r\n\r\n        self.get_logger().info('Collecting IMU samples...')\r\n\r\n    def imu_callback(self, msg):\r\n        self.accel_samples.append([\r\n            msg.linear_acceleration.x,\r\n            msg.linear_acceleration.y,\r\n            msg.linear_acceleration.z\r\n        ])\r\n        self.gyro_samples.append([\r\n            msg.angular_velocity.x,\r\n            msg.angular_velocity.y,\r\n            msg.angular_velocity.z\r\n        ])\r\n\r\n    def report_stats(self):\r\n        if len(self.accel_samples) < 100:\r\n            return\r\n\r\n        accel = np.array(self.accel_samples)\r\n        gyro = np.array(self.gyro_samples)\r\n\r\n        # Accelerometer statistics\r\n        # Z should be ~9.81, X and Y should be ~0\r\n        accel_mean = np.mean(accel, axis=0)\r\n        accel_std = np.std(accel, axis=0)\r\n\r\n        self.get_logger().info(\r\n            f'Accel mean: [{accel_mean[0]:.4f}, {accel_mean[1]:.4f}, {accel_mean[2]:.4f}] m/s\xb2'\r\n        )\r\n        self.get_logger().info(\r\n            f'Accel std:  [{accel_std[0]:.4f}, {accel_std[1]:.4f}, {accel_std[2]:.4f}] m/s\xb2'\r\n        )\r\n\r\n        # Gyroscope statistics (should all be ~0)\r\n        gyro_mean = np.mean(gyro, axis=0)\r\n        gyro_std = np.std(gyro, axis=0)\r\n\r\n        self.get_logger().info(\r\n            f'Gyro mean:  [{gyro_mean[0]:.6f}, {gyro_mean[1]:.6f}, {gyro_mean[2]:.6f}] rad/s'\r\n        )\r\n        self.get_logger().info(\r\n            f'Gyro std:   [{gyro_std[0]:.6f}, {gyro_std[1]:.6f}, {gyro_std[2]:.6f}] rad/s'\r\n        )\r\n\r\n        # Compare to expected (from SDF configuration)\r\n        expected_accel_std = 0.039  # From MPU-6050 config\r\n        expected_gyro_std = 0.00087\r\n\r\n        self.get_logger().info(\r\n            f'Expected accel std: {expected_accel_std}, measured: {np.mean(accel_std):.4f}'\r\n        )\r\n        self.get_logger().info(\r\n            f'Expected gyro std: {expected_gyro_std}, measured: {np.mean(gyro_std):.6f}'\r\n        )\r\n\r\n\r\ndef main():\r\n    rclpy.init()\r\n    node = ImuValidator()\r\n    rclpy.spin(node)\r\n    node.destroy_node()\r\n    rclpy.shutdown()\r\n\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,i.jsx)(n.p,{children:"This chapter covered configuring simulated sensors with realistic noise:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Camera simulation"})," requires matching resolution, FOV, and frame rate. Add Gaussian noise based on sensor SNR."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"LiDAR simulation"})," uses ray-casting; configure range, resolution, and Gaussian range noise. Be aware of ray-casting limitations."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"IMU simulation"})," requires configuring both accelerometer and gyroscope noise from datasheet noise density values."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Depth cameras"})," have distance-dependent noise that simple Gaussian models approximate."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Validation"})," compares simulated sensor statistics to expected values from configuration."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"reality-gap-callout",children:"Reality Gap Callout"}),"\n",(0,i.jsx)(n.p,{children:"Even with noise models, simulated sensors differ from real sensors:"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Sensor"}),(0,i.jsx)(n.th,{children:"What Simulation Misses"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Camera"}),(0,i.jsx)(n.td,{children:"Motion blur, lens flare, hot pixels, banding"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"LiDAR"}),(0,i.jsx)(n.td,{children:"Multi-path, translucent materials, retroreflection"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"IMU"}),(0,i.jsx)(n.td,{children:"Non-Gaussian outliers, temperature dependence"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Depth"}),(0,i.jsx)(n.td,{children:"Edge artifacts, reflective surface failures"})]})]})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Your algorithms must be robust to these unmodeled effects."})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"self-assessment-questions",children:"Self-Assessment Questions"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Camera Configuration"}),": You have an Intel RealSense D435 with 87\xb0 horizontal FOV. Convert this to radians for the ",(0,i.jsx)(n.code,{children:"<horizontal_fov>"})," element."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"LiDAR Noise"}),": Your LiDAR datasheet shows 3cm range accuracy (1\u03c3). What ",(0,i.jsx)(n.code,{children:"<stddev>"})," value would you use?"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"IMU Validation"}),": After collecting 1000 IMU samples, your measured gyro stddev is 0.002 rad/s but you configured 0.001 rad/s. What could cause this discrepancy?"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Depth Camera"}),": Your depth camera shows increasing noise at far distances, but simulation has constant noise. How would you handle this in algorithm development?"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Bridge Configuration"}),": Your camera publishes to ",(0,i.jsx)(n.code,{children:"/camera/image_raw"})," in Gazebo but your ROS 2 node subscribes to ",(0,i.jsx)(n.code,{children:"/front_camera/image"}),". What would you change?"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"whats-next",children:"What's Next"}),"\n",(0,i.jsxs)(n.p,{children:["In ",(0,i.jsx)(n.a,{href:"/module-3/chapter-4-simulated-actuators",children:"Chapter 4: Simulated Actuators"}),", you'll configure simulated motors and joint controllers with realistic delay, saturation, and friction\u2014applying Module 1's actuator analysis to simulation."]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(o,{...e})}):o(e)}}}]);