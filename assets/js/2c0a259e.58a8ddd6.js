"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[4958],{6100(r,e,n){n.r(e),n.d(e,{assets:()=>p,contentTitle:()=>s,default:()=>_,frontMatter:()=>i,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"capstone/chapter-4-manipulation","title":"Chapter 4: Manipulation System","description":"Chapter Goal","source":"@site/docs/capstone/chapter-4-manipulation.md","sourceDirName":"capstone","slug":"/capstone/chapter-4-manipulation","permalink":"/Master-Robotics-AI/textbook/capstone/chapter-4-manipulation","draft":false,"unlisted":false,"editUrl":"https://github.com/HasnainCodeHub/Master-Robotics-AI/tree/main/docs/docs/capstone/chapter-4-manipulation.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"id":"chapter-4-manipulation","title":"Chapter 4: Manipulation System","sidebar_label":"4. Manipulation","sidebar_position":5},"sidebar":"textbookSidebar","previous":{"title":"3. Navigation","permalink":"/Master-Robotics-AI/textbook/capstone/chapter-3-navigation"},"next":{"title":"5. Integration","permalink":"/Master-Robotics-AI/textbook/capstone/chapter-5-integration"}}');var o=n(4848),a=n(8453);const i={id:"chapter-4-manipulation",title:"Chapter 4: Manipulation System",sidebar_label:"4. Manipulation",sidebar_position:5},s="Chapter 4: Manipulation System Implementation",p={},l=[{value:"Chapter Goal",id:"chapter-goal",level:2},{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"MoveIt 2 Configuration",id:"moveit-config",level:2},{value:"SRDF Definition",id:"srdf-definition",level:3},{value:"MoveIt Configuration Files",id:"moveit-configuration-files",level:3},{value:"MoveIt 2 Interface",id:"moveit-interface",level:2},{value:"Arm Controller",id:"arm-controller",level:3},{value:"Pick and Place Actions",id:"pick-place",level:2},{value:"Pick Action Server",id:"pick-action-server",level:3},{value:"Place Action Server",id:"place-action-server",level:3},{value:"Grasp Planning",id:"grasp-planning",level:2},{value:"Grasp Pose Generation",id:"grasp-pose-generation",level:3},{value:"Bimanual Coordination",id:"bimanual",level:2},{value:"Coordinated Dual-Arm Operations",id:"coordinated-dual-arm-operations",level:3},{value:"Summary",id:"summary",level:2},{value:"Manipulation Checklist",id:"manipulation-checklist",level:2},{value:"What&#39;s Next",id:"whats-next",level:2}];function c(r){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",input:"input",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...r.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.header,{children:(0,o.jsx)(e.h1,{id:"chapter-4-manipulation-system-implementation",children:"Chapter 4: Manipulation System Implementation"})}),"\n",(0,o.jsx)(e.h2,{id:"chapter-goal",children:"Chapter Goal"}),"\n",(0,o.jsxs)(e.p,{children:["By the end of this chapter, you will have ",(0,o.jsx)(e.strong,{children:"implemented a complete manipulation system"})," using MoveIt 2 for motion planning, with pick and place capabilities for both arms and coordinated bimanual operations."]}),"\n",(0,o.jsx)(e.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,o.jsx)(e.p,{children:"After completing this chapter, you will be able to:"}),"\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"ID"}),(0,o.jsx)(e.th,{children:"Objective"})]})}),(0,o.jsxs)(e.tbody,{children:[(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"4.1"}),(0,o.jsx)(e.td,{children:"Configure MoveIt 2 for dual-arm humanoid"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"4.2"}),(0,o.jsx)(e.td,{children:"Implement pick and place action servers"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"4.3"}),(0,o.jsx)(e.td,{children:"Integrate grasp planning with perception"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"4.4"}),(0,o.jsx)(e.td,{children:"Implement coordinated bimanual manipulation"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:"4.5"}),(0,o.jsx)(e.td,{children:"Handle manipulation failures with recovery"})]})]})]}),"\n",(0,o.jsx)(e.hr,{}),"\n",(0,o.jsx)(e.h2,{id:"moveit-config",children:"MoveIt 2 Configuration"}),"\n",(0,o.jsx)(e.h3,{id:"srdf-definition",children:"SRDF Definition"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-xml",children:'\x3c!-- humanoid.srdf --\x3e\r\n<?xml version="1.0"?>\r\n<robot name="humanoid">\r\n  \x3c!-- Planning groups --\x3e\r\n  <group name="left_arm">\r\n    <chain base_link="torso_link" tip_link="left_arm_ee_link"/>\r\n  </group>\r\n\r\n  <group name="right_arm">\r\n    <chain base_link="torso_link" tip_link="right_arm_ee_link"/>\r\n  </group>\r\n\r\n  <group name="left_gripper">\r\n    <joint name="left_gripper_joint_1"/>\r\n    <joint name="left_gripper_joint_2"/>\r\n  </group>\r\n\r\n  <group name="right_gripper">\r\n    <joint name="right_gripper_joint_1"/>\r\n    <joint name="right_gripper_joint_2"/>\r\n  </group>\r\n\r\n  <group name="both_arms">\r\n    <group name="left_arm"/>\r\n    <group name="right_arm"/>\r\n  </group>\r\n\r\n  \x3c!-- End effectors --\x3e\r\n  <end_effector name="left_gripper" parent_link="left_arm_ee_link"\r\n                group="left_gripper" parent_group="left_arm"/>\r\n  <end_effector name="right_gripper" parent_link="right_arm_ee_link"\r\n                group="right_gripper" parent_group="right_arm"/>\r\n\r\n  \x3c!-- Disabled collisions (adjacent links) --\x3e\r\n  <disable_collisions link1="torso_link" link2="left_arm_link_1" reason="Adjacent"/>\r\n  <disable_collisions link1="left_arm_link_1" link2="left_arm_link_2" reason="Adjacent"/>\r\n  \x3c!-- ... more collision pairs ... --\x3e\r\n\r\n  \x3c!-- Named poses --\x3e\r\n  <group_state name="home" group="left_arm">\r\n    <joint name="left_arm_joint_1" value="0"/>\r\n    <joint name="left_arm_joint_2" value="0"/>\r\n    <joint name="left_arm_joint_3" value="0"/>\r\n    <joint name="left_arm_joint_4" value="-1.57"/>\r\n    <joint name="left_arm_joint_5" value="0"/>\r\n    <joint name="left_arm_joint_6" value="1.57"/>\r\n    <joint name="left_arm_joint_7" value="0"/>\r\n  </group_state>\r\n\r\n  <group_state name="home" group="right_arm">\r\n    <joint name="right_arm_joint_1" value="0"/>\r\n    <joint name="right_arm_joint_2" value="0"/>\r\n    <joint name="right_arm_joint_3" value="0"/>\r\n    <joint name="right_arm_joint_4" value="-1.57"/>\r\n    <joint name="right_arm_joint_5" value="0"/>\r\n    <joint name="right_arm_joint_6" value="1.57"/>\r\n    <joint name="right_arm_joint_7" value="0"/>\r\n  </group_state>\r\n\r\n  <group_state name="open" group="left_gripper">\r\n    <joint name="left_gripper_joint_1" value="0.04"/>\r\n    <joint name="left_gripper_joint_2" value="0.04"/>\r\n  </group_state>\r\n\r\n  <group_state name="closed" group="left_gripper">\r\n    <joint name="left_gripper_joint_1" value="0"/>\r\n    <joint name="left_gripper_joint_2" value="0"/>\r\n  </group_state>\r\n</robot>\n'})}),"\n",(0,o.jsx)(e.h3,{id:"moveit-configuration-files",children:"MoveIt Configuration Files"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-yaml",children:"# config/moveit/kinematics.yaml\r\n\r\nleft_arm:\r\n  kinematics_solver: kdl_kinematics_plugin/KDLKinematicsPlugin\r\n  kinematics_solver_search_resolution: 0.005\r\n  kinematics_solver_timeout: 0.05\r\n\r\nright_arm:\r\n  kinematics_solver: kdl_kinematics_plugin/KDLKinematicsPlugin\r\n  kinematics_solver_search_resolution: 0.005\r\n  kinematics_solver_timeout: 0.05\r\n\r\nboth_arms:\r\n  kinematics_solver: kdl_kinematics_plugin/KDLKinematicsPlugin\r\n  kinematics_solver_search_resolution: 0.005\r\n  kinematics_solver_timeout: 0.1\n"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-yaml",children:"# config/moveit/ompl_planning.yaml\r\n\r\nplanner_configs:\r\n  RRTConnectkConfigDefault:\r\n    type: geometric::RRTConnect\r\n    range: 0.0\r\n\r\n  RRTstarkConfigDefault:\r\n    type: geometric::RRTstar\r\n    range: 0.0\r\n\r\n  PRMkConfigDefault:\r\n    type: geometric::PRM\r\n    max_nearest_neighbors: 10\r\n\r\nleft_arm:\r\n  default_planner_config: RRTConnectkConfigDefault\r\n  planner_configs:\r\n    - RRTConnectkConfigDefault\r\n    - RRTstarkConfigDefault\r\n  projection_evaluator: joints(left_arm_joint_1,left_arm_joint_2)\r\n  longest_valid_segment_fraction: 0.005\r\n\r\nright_arm:\r\n  default_planner_config: RRTConnectkConfigDefault\r\n  planner_configs:\r\n    - RRTConnectkConfigDefault\r\n    - RRTstarkConfigDefault\r\n  projection_evaluator: joints(right_arm_joint_1,right_arm_joint_2)\r\n  longest_valid_segment_fraction: 0.005\n"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-yaml",children:"# config/moveit/joint_limits.yaml\r\n\r\njoint_limits:\r\n  left_arm_joint_1:\r\n    has_velocity_limits: true\r\n    max_velocity: 2.0\r\n    has_acceleration_limits: true\r\n    max_acceleration: 3.0\r\n\r\n  left_arm_joint_2:\r\n    has_velocity_limits: true\r\n    max_velocity: 2.0\r\n    has_acceleration_limits: true\r\n    max_acceleration: 3.0\r\n\r\n  # ... similar for other joints ...\r\n\r\n  left_gripper_joint_1:\r\n    has_velocity_limits: true\r\n    max_velocity: 0.5\r\n    has_acceleration_limits: true\r\n    max_acceleration: 1.0\n"})}),"\n",(0,o.jsx)(e.hr,{}),"\n",(0,o.jsx)(e.h2,{id:"moveit-interface",children:"MoveIt 2 Interface"}),"\n",(0,o.jsx)(e.h3,{id:"arm-controller",children:"Arm Controller"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:"#!/usr/bin/env python3\r\n\"\"\"MoveIt 2 interface for humanoid arms.\"\"\"\r\n\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom geometry_msgs.msg import Pose, PoseStamped\r\nfrom moveit_msgs.msg import Constraints, PositionConstraint, OrientationConstraint\r\nfrom moveit_msgs.msg import BoundingVolume\r\nfrom shape_msgs.msg import SolidPrimitive\r\nfrom moveit_msgs.action import MoveGroup, ExecuteTrajectory\r\nfrom moveit_msgs.srv import GetPositionIK\r\nfrom rclpy.action import ActionClient\r\nimport numpy as np\r\n\r\n\r\nclass ArmController(Node):\r\n    \"\"\"Control humanoid arms via MoveIt 2.\"\"\"\r\n\r\n    def __init__(self):\r\n        super().__init__('arm_controller')\r\n\r\n        # Action clients\r\n        self.move_group_clients = {\r\n            'left_arm': ActionClient(self, MoveGroup, '/move_action'),\r\n            'right_arm': ActionClient(self, MoveGroup, '/move_action'),\r\n        }\r\n\r\n        self.execute_client = ActionClient(\r\n            self, ExecuteTrajectory, '/execute_trajectory'\r\n        )\r\n\r\n        # IK service\r\n        self.ik_client = self.create_client(\r\n            GetPositionIK, '/compute_ik'\r\n        )\r\n\r\n        # Gripper publishers\r\n        self.gripper_pubs = {\r\n            'left': self.create_publisher(\r\n                Float64MultiArray, '/left_gripper_controller/commands', 10\r\n            ),\r\n            'right': self.create_publisher(\r\n                Float64MultiArray, '/right_gripper_controller/commands', 10\r\n            ),\r\n        }\r\n\r\n        self.get_logger().info('Arm controller initialized')\r\n\r\n    async def move_to_pose(\r\n        self,\r\n        arm: str,\r\n        target_pose: Pose,\r\n        velocity_scaling: float = 0.5,\r\n        acceleration_scaling: float = 0.5\r\n    ) -> bool:\r\n        \"\"\"Move arm to target pose.\"\"\"\r\n        self.get_logger().info(f'Moving {arm} to pose')\r\n\r\n        # Create goal\r\n        goal = MoveGroup.Goal()\r\n        goal.request.group_name = arm\r\n        goal.request.num_planning_attempts = 5\r\n        goal.request.allowed_planning_time = 5.0\r\n        goal.request.max_velocity_scaling_factor = velocity_scaling\r\n        goal.request.max_acceleration_scaling_factor = acceleration_scaling\r\n\r\n        # Set target\r\n        pose_stamped = PoseStamped()\r\n        pose_stamped.header.frame_id = 'torso_link'\r\n        pose_stamped.pose = target_pose\r\n\r\n        # Create position constraint\r\n        position_constraint = PositionConstraint()\r\n        position_constraint.header = pose_stamped.header\r\n        position_constraint.link_name = f'{arm}_ee_link'\r\n        position_constraint.target_point_offset.x = 0.0\r\n        position_constraint.target_point_offset.y = 0.0\r\n        position_constraint.target_point_offset.z = 0.0\r\n\r\n        # Bounding volume (sphere around target)\r\n        bounding_volume = BoundingVolume()\r\n        sphere = SolidPrimitive()\r\n        sphere.type = SolidPrimitive.SPHERE\r\n        sphere.dimensions = [0.01]  # 1cm tolerance\r\n        bounding_volume.primitives.append(sphere)\r\n        bounding_volume.primitive_poses.append(target_pose)\r\n        position_constraint.constraint_region = bounding_volume\r\n        position_constraint.weight = 1.0\r\n\r\n        # Create orientation constraint\r\n        orientation_constraint = OrientationConstraint()\r\n        orientation_constraint.header = pose_stamped.header\r\n        orientation_constraint.link_name = f'{arm}_ee_link'\r\n        orientation_constraint.orientation = target_pose.orientation\r\n        orientation_constraint.absolute_x_axis_tolerance = 0.1\r\n        orientation_constraint.absolute_y_axis_tolerance = 0.1\r\n        orientation_constraint.absolute_z_axis_tolerance = 0.1\r\n        orientation_constraint.weight = 1.0\r\n\r\n        # Add to goal constraints\r\n        constraints = Constraints()\r\n        constraints.position_constraints.append(position_constraint)\r\n        constraints.orientation_constraints.append(orientation_constraint)\r\n        goal.request.goal_constraints.append(constraints)\r\n\r\n        # Send goal\r\n        client = self.move_group_clients[arm]\r\n        if not client.wait_for_server(timeout_sec=5.0):\r\n            self.get_logger().error('MoveGroup server not available')\r\n            return False\r\n\r\n        result = await client.send_goal_async(goal)\r\n\r\n        if not result.accepted:\r\n            self.get_logger().warn('Goal rejected')\r\n            return False\r\n\r\n        final_result = await result.get_result_async()\r\n        success = final_result.result.error_code.val == 1  # SUCCESS\r\n\r\n        if success:\r\n            self.get_logger().info(f'{arm} reached target')\r\n        else:\r\n            self.get_logger().warn(f'{arm} failed: {final_result.result.error_code}')\r\n\r\n        return success\r\n\r\n    async def move_to_named_pose(self, arm: str, pose_name: str) -> bool:\r\n        \"\"\"Move to named pose (e.g., 'home').\"\"\"\r\n        goal = MoveGroup.Goal()\r\n        goal.request.group_name = arm\r\n        goal.request.start_state.is_diff = True\r\n\r\n        # Named target\r\n        goal.request.goal_constraints = []  # Clear pose constraints\r\n        # Named targets handled by planner\r\n\r\n        client = self.move_group_clients[arm]\r\n        result = await client.send_goal_async(goal)\r\n\r\n        return result.accepted\r\n\r\n    def open_gripper(self, side: str):\r\n        \"\"\"Open gripper.\"\"\"\r\n        msg = Float64MultiArray()\r\n        msg.data = [0.04, 0.04]  # Open position\r\n        self.gripper_pubs[side].publish(msg)\r\n        self.get_logger().info(f'{side} gripper opened')\r\n\r\n    def close_gripper(self, side: str, width: float = 0.0):\r\n        \"\"\"Close gripper to specified width.\"\"\"\r\n        msg = Float64MultiArray()\r\n        msg.data = [width / 2, width / 2]\r\n        self.gripper_pubs[side].publish(msg)\r\n        self.get_logger().info(f'{side} gripper closed to {width}m')\r\n\r\n    async def compute_ik(self, arm: str, pose: Pose) -> list:\r\n        \"\"\"Compute inverse kinematics for pose.\"\"\"\r\n        request = GetPositionIK.Request()\r\n        request.ik_request.group_name = arm\r\n        request.ik_request.pose_stamped.header.frame_id = 'torso_link'\r\n        request.ik_request.pose_stamped.pose = pose\r\n        request.ik_request.timeout.sec = 1\r\n\r\n        future = self.ik_client.call_async(request)\r\n        response = await future\r\n\r\n        if response.error_code.val == 1:  # SUCCESS\r\n            return list(response.solution.joint_state.position)\r\n        else:\r\n            return None\n"})}),"\n",(0,o.jsx)(e.hr,{}),"\n",(0,o.jsx)(e.h2,{id:"pick-place",children:"Pick and Place Actions"}),"\n",(0,o.jsx)(e.h3,{id:"pick-action-server",children:"Pick Action Server"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:"#!/usr/bin/env python3\r\n\"\"\"Pick action server for humanoid manipulation.\"\"\"\r\n\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom rclpy.action import ActionServer\r\nfrom humanoid_msgs.action import Pick\r\nfrom geometry_msgs.msg import Pose, PoseStamped\r\nimport numpy as np\r\nimport time\r\n\r\n\r\nclass PickActionServer(Node):\r\n    \"\"\"Execute pick operations.\"\"\"\r\n\r\n    def __init__(self, arm_controller: ArmController):\r\n        super().__init__('pick_action_server')\r\n\r\n        self.arm = arm_controller\r\n\r\n        # Action server\r\n        self.action_server = ActionServer(\r\n            self,\r\n            Pick,\r\n            'humanoid/pick',\r\n            execute_callback=self.execute_pick\r\n        )\r\n\r\n        # Parameters\r\n        self.approach_distance = 0.1  # 10cm above object\r\n        self.lift_height = 0.15       # 15cm lift after grasp\r\n\r\n        self.get_logger().info('Pick action server ready')\r\n\r\n    async def execute_pick(self, goal_handle):\r\n        \"\"\"Execute pick sequence.\"\"\"\r\n        target = goal_handle.request.target_pose\r\n        arm = goal_handle.request.arm  # 'left' or 'right'\r\n        object_width = goal_handle.request.object_width\r\n\r\n        self.get_logger().info(f'Picking object with {arm} arm')\r\n\r\n        feedback = Pick.Feedback()\r\n\r\n        # Phase 1: Open gripper\r\n        feedback.phase = 'opening_gripper'\r\n        feedback.progress = 0.1\r\n        goal_handle.publish_feedback(feedback)\r\n\r\n        self.arm.open_gripper(arm)\r\n        time.sleep(0.5)\r\n\r\n        # Phase 2: Move to approach pose\r\n        feedback.phase = 'approaching'\r\n        feedback.progress = 0.2\r\n        goal_handle.publish_feedback(feedback)\r\n\r\n        approach_pose = self.compute_approach_pose(target)\r\n        success = await self.arm.move_to_pose(arm, approach_pose)\r\n\r\n        if not success:\r\n            self.get_logger().error('Failed to reach approach pose')\r\n            goal_handle.abort()\r\n            return Pick.Result(success=False, message='Approach failed')\r\n\r\n        # Phase 3: Move to grasp pose\r\n        feedback.phase = 'reaching'\r\n        feedback.progress = 0.4\r\n        goal_handle.publish_feedback(feedback)\r\n\r\n        grasp_pose = self.compute_grasp_pose(target)\r\n        success = await self.arm.move_to_pose(\r\n            arm, grasp_pose,\r\n            velocity_scaling=0.3  # Slower for precision\r\n        )\r\n\r\n        if not success:\r\n            self.get_logger().error('Failed to reach grasp pose')\r\n            goal_handle.abort()\r\n            return Pick.Result(success=False, message='Grasp approach failed')\r\n\r\n        # Phase 4: Close gripper\r\n        feedback.phase = 'grasping'\r\n        feedback.progress = 0.6\r\n        goal_handle.publish_feedback(feedback)\r\n\r\n        self.arm.close_gripper(arm, object_width)\r\n        time.sleep(0.5)\r\n\r\n        # Phase 5: Lift\r\n        feedback.phase = 'lifting'\r\n        feedback.progress = 0.8\r\n        goal_handle.publish_feedback(feedback)\r\n\r\n        lift_pose = self.compute_lift_pose(grasp_pose)\r\n        success = await self.arm.move_to_pose(arm, lift_pose)\r\n\r\n        if not success:\r\n            self.get_logger().warn('Lift failed, attempting recovery')\r\n            # Recovery: try to lift anyway\r\n            lift_pose.position.z += 0.05\r\n            success = await self.arm.move_to_pose(arm, lift_pose)\r\n\r\n        # Complete\r\n        feedback.phase = 'complete'\r\n        feedback.progress = 1.0\r\n        goal_handle.publish_feedback(feedback)\r\n\r\n        if success:\r\n            goal_handle.succeed()\r\n            return Pick.Result(success=True, message='Pick successful')\r\n        else:\r\n            goal_handle.abort()\r\n            return Pick.Result(success=False, message='Lift failed')\r\n\r\n    def compute_approach_pose(self, target: Pose) -> Pose:\r\n        \"\"\"Compute approach pose above target.\"\"\"\r\n        approach = Pose()\r\n        approach.position.x = target.position.x\r\n        approach.position.y = target.position.y\r\n        approach.position.z = target.position.z + self.approach_distance\r\n\r\n        # Top-down grasp orientation\r\n        approach.orientation.x = 0.707\r\n        approach.orientation.y = 0.707\r\n        approach.orientation.z = 0.0\r\n        approach.orientation.w = 0.0\r\n\r\n        return approach\r\n\r\n    def compute_grasp_pose(self, target: Pose) -> Pose:\r\n        \"\"\"Compute grasp pose at target.\"\"\"\r\n        grasp = Pose()\r\n        grasp.position = target.position\r\n\r\n        # Same orientation as approach\r\n        grasp.orientation.x = 0.707\r\n        grasp.orientation.y = 0.707\r\n        grasp.orientation.z = 0.0\r\n        grasp.orientation.w = 0.0\r\n\r\n        return grasp\r\n\r\n    def compute_lift_pose(self, grasp: Pose) -> Pose:\r\n        \"\"\"Compute lift pose above grasp.\"\"\"\r\n        lift = Pose()\r\n        lift.position.x = grasp.position.x\r\n        lift.position.y = grasp.position.y\r\n        lift.position.z = grasp.position.z + self.lift_height\r\n        lift.orientation = grasp.orientation\r\n\r\n        return lift\n"})}),"\n",(0,o.jsx)(e.h3,{id:"place-action-server",children:"Place Action Server"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:"#!/usr/bin/env python3\r\n\"\"\"Place action server for humanoid manipulation.\"\"\"\r\n\r\nfrom humanoid_msgs.action import Place\r\n\r\n\r\nclass PlaceActionServer(Node):\r\n    \"\"\"Execute place operations.\"\"\"\r\n\r\n    def __init__(self, arm_controller: ArmController):\r\n        super().__init__('place_action_server')\r\n\r\n        self.arm = arm_controller\r\n\r\n        self.action_server = ActionServer(\r\n            self,\r\n            Place,\r\n            'humanoid/place',\r\n            execute_callback=self.execute_place\r\n        )\r\n\r\n        self.approach_distance = 0.1\r\n        self.place_offset = 0.02  # Small offset above surface\r\n\r\n        self.get_logger().info('Place action server ready')\r\n\r\n    async def execute_place(self, goal_handle):\r\n        \"\"\"Execute place sequence.\"\"\"\r\n        target = goal_handle.request.target_pose\r\n        arm = goal_handle.request.arm\r\n\r\n        self.get_logger().info(f'Placing object with {arm} arm')\r\n\r\n        feedback = Place.Feedback()\r\n\r\n        # Phase 1: Move to approach pose\r\n        feedback.phase = 'approaching'\r\n        feedback.progress = 0.2\r\n        goal_handle.publish_feedback(feedback)\r\n\r\n        approach_pose = Pose()\r\n        approach_pose.position.x = target.position.x\r\n        approach_pose.position.y = target.position.y\r\n        approach_pose.position.z = target.position.z + self.approach_distance\r\n        approach_pose.orientation = target.orientation\r\n\r\n        success = await self.arm.move_to_pose(arm, approach_pose)\r\n\r\n        if not success:\r\n            goal_handle.abort()\r\n            return Place.Result(success=False, message='Approach failed')\r\n\r\n        # Phase 2: Move to place pose\r\n        feedback.phase = 'placing'\r\n        feedback.progress = 0.5\r\n        goal_handle.publish_feedback(feedback)\r\n\r\n        place_pose = Pose()\r\n        place_pose.position.x = target.position.x\r\n        place_pose.position.y = target.position.y\r\n        place_pose.position.z = target.position.z + self.place_offset\r\n        place_pose.orientation = target.orientation\r\n\r\n        success = await self.arm.move_to_pose(\r\n            arm, place_pose,\r\n            velocity_scaling=0.3\r\n        )\r\n\r\n        if not success:\r\n            goal_handle.abort()\r\n            return Place.Result(success=False, message='Place motion failed')\r\n\r\n        # Phase 3: Open gripper\r\n        feedback.phase = 'releasing'\r\n        feedback.progress = 0.7\r\n        goal_handle.publish_feedback(feedback)\r\n\r\n        self.arm.open_gripper(arm)\r\n        time.sleep(0.5)\r\n\r\n        # Phase 4: Retreat\r\n        feedback.phase = 'retreating'\r\n        feedback.progress = 0.9\r\n        goal_handle.publish_feedback(feedback)\r\n\r\n        retreat_pose = Pose()\r\n        retreat_pose.position.x = place_pose.position.x\r\n        retreat_pose.position.y = place_pose.position.y\r\n        retreat_pose.position.z = place_pose.position.z + self.approach_distance\r\n        retreat_pose.orientation = place_pose.orientation\r\n\r\n        await self.arm.move_to_pose(arm, retreat_pose)\r\n\r\n        # Complete\r\n        feedback.phase = 'complete'\r\n        feedback.progress = 1.0\r\n        goal_handle.publish_feedback(feedback)\r\n\r\n        goal_handle.succeed()\r\n        return Place.Result(success=True, message='Place successful')\n"})}),"\n",(0,o.jsx)(e.hr,{}),"\n",(0,o.jsx)(e.h2,{id:"grasp-planning",children:"Grasp Planning"}),"\n",(0,o.jsx)(e.h3,{id:"grasp-pose-generation",children:"Grasp Pose Generation"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'#!/usr/bin/env python3\r\n"""Generate grasp poses for detected objects."""\r\n\r\nimport numpy as np\r\nfrom geometry_msgs.msg import Pose\r\nfrom typing import List, Optional\r\nfrom dataclasses import dataclass\r\n\r\n\r\n@dataclass\r\nclass GraspPose:\r\n    """A candidate grasp pose with metadata."""\r\n    pose: Pose\r\n    approach_direction: np.ndarray\r\n    grasp_width: float\r\n    score: float\r\n\r\n\r\nclass GraspPlanner:\r\n    """Generate and rank grasp poses."""\r\n\r\n    def __init__(self):\r\n        # Gripper parameters\r\n        self.gripper_depth = 0.08  # How far fingers extend\r\n        self.max_gripper_width = 0.08\r\n        self.min_gripper_width = 0.0\r\n\r\n    def generate_grasps(\r\n        self,\r\n        object_pose: Pose,\r\n        object_dimensions: List[float],\r\n        object_class: str\r\n    ) -> List[GraspPose]:\r\n        """Generate candidate grasp poses for object."""\r\n        grasps = []\r\n\r\n        # Object center\r\n        center = np.array([\r\n            object_pose.position.x,\r\n            object_pose.position.y,\r\n            object_pose.position.z\r\n        ])\r\n\r\n        # Object size\r\n        width, depth, height = object_dimensions\r\n\r\n        # Generate grasps based on object type\r\n        if object_class in [\'mug\', \'cup\', \'bottle\']:\r\n            grasps.extend(self.generate_cylindrical_grasps(\r\n                center, max(width, depth), height\r\n            ))\r\n        elif object_class in [\'box\', \'book\']:\r\n            grasps.extend(self.generate_box_grasps(\r\n                center, width, depth, height\r\n            ))\r\n        else:\r\n            # Generic grasp generation\r\n            grasps.extend(self.generate_generic_grasps(\r\n                center, max(width, depth, height)\r\n            ))\r\n\r\n        # Sort by score\r\n        grasps.sort(key=lambda g: g.score, reverse=True)\r\n\r\n        return grasps\r\n\r\n    def generate_cylindrical_grasps(\r\n        self,\r\n        center: np.ndarray,\r\n        diameter: float,\r\n        height: float\r\n    ) -> List[GraspPose]:\r\n        """Generate grasps for cylindrical objects."""\r\n        grasps = []\r\n\r\n        # Top-down grasp (best for mugs/bottles)\r\n        if diameter < self.max_gripper_width:\r\n            grasp = self.create_top_grasp(center, diameter)\r\n            grasp.score = 0.9  # High score for top grasp\r\n            grasps.append(grasp)\r\n\r\n        # Side grasps at different angles\r\n        for angle in np.linspace(0, np.pi, 4):\r\n            grasp = self.create_side_grasp(center, diameter, height, angle)\r\n            grasp.score = 0.7\r\n            grasps.append(grasp)\r\n\r\n        return grasps\r\n\r\n    def generate_box_grasps(\r\n        self,\r\n        center: np.ndarray,\r\n        width: float,\r\n        depth: float,\r\n        height: float\r\n    ) -> List[GraspPose]:\r\n        """Generate grasps for box-shaped objects."""\r\n        grasps = []\r\n\r\n        # Grasp along shorter dimension\r\n        if width < depth and width < self.max_gripper_width:\r\n            # Grasp across width\r\n            grasp = self.create_side_grasp(center, width, height, 0)\r\n            grasp.score = 0.8\r\n            grasps.append(grasp)\r\n\r\n            grasp = self.create_side_grasp(center, width, height, np.pi)\r\n            grasp.score = 0.8\r\n            grasps.append(grasp)\r\n\r\n        if depth < width and depth < self.max_gripper_width:\r\n            # Grasp across depth\r\n            grasp = self.create_side_grasp(center, depth, height, np.pi/2)\r\n            grasp.score = 0.8\r\n            grasps.append(grasp)\r\n\r\n        # Top grasp if thin enough\r\n        if min(width, depth) < self.max_gripper_width:\r\n            grasp = self.create_top_grasp(center, min(width, depth))\r\n            grasp.score = 0.6  # Lower score for boxes\r\n            grasps.append(grasp)\r\n\r\n        return grasps\r\n\r\n    def create_top_grasp(\r\n        self,\r\n        center: np.ndarray,\r\n        width: float\r\n    ) -> GraspPose:\r\n        """Create top-down grasp pose."""\r\n        pose = Pose()\r\n        pose.position.x = center[0]\r\n        pose.position.y = center[1]\r\n        pose.position.z = center[2]\r\n\r\n        # Top-down orientation (gripper pointing down)\r\n        pose.orientation.x = 0.707\r\n        pose.orientation.y = 0.707\r\n        pose.orientation.z = 0.0\r\n        pose.orientation.w = 0.0\r\n\r\n        return GraspPose(\r\n            pose=pose,\r\n            approach_direction=np.array([0, 0, -1]),\r\n            grasp_width=width + 0.01,  # Small margin\r\n            score=0.0\r\n        )\r\n\r\n    def create_side_grasp(\r\n        self,\r\n        center: np.ndarray,\r\n        width: float,\r\n        height: float,\r\n        angle: float\r\n    ) -> GraspPose:\r\n        """Create side grasp pose at given angle."""\r\n        pose = Pose()\r\n        pose.position.x = center[0]\r\n        pose.position.y = center[1]\r\n        pose.position.z = center[2]\r\n\r\n        # Horizontal grasp orientation\r\n        # Quaternion for rotation around Z then pointing horizontally\r\n        qw = np.cos(angle / 2)\r\n        qz = np.sin(angle / 2)\r\n\r\n        pose.orientation.x = 0.5\r\n        pose.orientation.y = 0.5\r\n        pose.orientation.z = 0.5 * qz / max(0.001, np.sqrt(1 - qw*qw)) if qw < 0.99 else 0\r\n        pose.orientation.w = 0.5\r\n\r\n        approach = np.array([np.cos(angle), np.sin(angle), 0])\r\n\r\n        return GraspPose(\r\n            pose=pose,\r\n            approach_direction=approach,\r\n            grasp_width=width + 0.01,\r\n            score=0.0\r\n        )\r\n\r\n    def generate_generic_grasps(\r\n        self,\r\n        center: np.ndarray,\r\n        size: float\r\n    ) -> List[GraspPose]:\r\n        """Generate generic grasps for unknown objects."""\r\n        grasps = []\r\n\r\n        # Top grasp if small enough\r\n        if size < self.max_gripper_width:\r\n            grasp = self.create_top_grasp(center, size)\r\n            grasp.score = 0.5\r\n            grasps.append(grasp)\r\n\r\n        return grasps\n'})}),"\n",(0,o.jsx)(e.hr,{}),"\n",(0,o.jsx)(e.h2,{id:"bimanual",children:"Bimanual Coordination"}),"\n",(0,o.jsx)(e.h3,{id:"coordinated-dual-arm-operations",children:"Coordinated Dual-Arm Operations"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:"#!/usr/bin/env python3\r\n\"\"\"Coordinated bimanual manipulation.\"\"\"\r\n\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom geometry_msgs.msg import Pose\r\nimport numpy as np\r\nfrom typing import Tuple\r\n\r\n\r\nclass BimanualController(Node):\r\n    \"\"\"Coordinate both arms for complex tasks.\"\"\"\r\n\r\n    def __init__(self, arm_controller: ArmController):\r\n        super().__init__('bimanual_controller')\r\n\r\n        self.arm = arm_controller\r\n\r\n        # Coordination parameters\r\n        self.sync_tolerance = 0.1  # Max allowed desync\r\n\r\n    async def handoff(\r\n        self,\r\n        from_arm: str,\r\n        to_arm: str,\r\n        object_width: float\r\n    ) -> bool:\r\n        \"\"\"Hand object from one arm to the other.\"\"\"\r\n        self.get_logger().info(f'Handoff from {from_arm} to {to_arm}')\r\n\r\n        # Calculate handoff position (center of workspace)\r\n        handoff_pose = Pose()\r\n        handoff_pose.position.x = 0.5\r\n        handoff_pose.position.y = 0.0\r\n        handoff_pose.position.z = 0.6\r\n\r\n        # Receiving arm orientation (facing giving arm)\r\n        handoff_pose.orientation.x = 0.5\r\n        handoff_pose.orientation.y = 0.5\r\n        handoff_pose.orientation.z = 0.5\r\n        handoff_pose.orientation.w = 0.5\r\n\r\n        # Move giving arm to handoff position\r\n        success = await self.arm.move_to_pose(from_arm, handoff_pose)\r\n        if not success:\r\n            return False\r\n\r\n        # Open receiving gripper\r\n        self.arm.open_gripper(to_arm)\r\n\r\n        # Move receiving arm to handoff position\r\n        receive_pose = Pose()\r\n        receive_pose.position.x = handoff_pose.position.x\r\n        receive_pose.position.y = handoff_pose.position.y\r\n        receive_pose.position.z = handoff_pose.position.z\r\n\r\n        # Opposite orientation\r\n        receive_pose.orientation.x = -0.5\r\n        receive_pose.orientation.y = 0.5\r\n        receive_pose.orientation.z = 0.5\r\n        receive_pose.orientation.w = 0.5\r\n\r\n        success = await self.arm.move_to_pose(to_arm, receive_pose)\r\n        if not success:\r\n            return False\r\n\r\n        # Close receiving gripper\r\n        self.arm.close_gripper(to_arm, object_width)\r\n\r\n        # Wait for grip\r\n        await asyncio.sleep(0.5)\r\n\r\n        # Open giving gripper\r\n        self.arm.open_gripper(from_arm)\r\n\r\n        # Retreat giving arm\r\n        retreat_pose = Pose()\r\n        retreat_pose.position.x = handoff_pose.position.x\r\n        retreat_pose.position.y = 0.3 if from_arm == 'left' else -0.3\r\n        retreat_pose.position.z = handoff_pose.position.z\r\n        retreat_pose.orientation = handoff_pose.orientation\r\n\r\n        await self.arm.move_to_pose(from_arm, retreat_pose)\r\n\r\n        self.get_logger().info('Handoff complete')\r\n        return True\r\n\r\n    async def synchronized_move(\r\n        self,\r\n        left_pose: Pose,\r\n        right_pose: Pose\r\n    ) -> bool:\r\n        \"\"\"Move both arms simultaneously.\"\"\"\r\n        self.get_logger().info('Synchronized bimanual move')\r\n\r\n        # Compute trajectories\r\n        left_ik = await self.arm.compute_ik('left_arm', left_pose)\r\n        right_ik = await self.arm.compute_ik('right_arm', right_pose)\r\n\r\n        if left_ik is None or right_ik is None:\r\n            self.get_logger().error('IK failed for synchronized move')\r\n            return False\r\n\r\n        # TODO: Implement synchronized trajectory execution\r\n        # This would require custom trajectory controller that\r\n        # synchronizes both arms\r\n\r\n        # For now, move sequentially\r\n        left_success = await self.arm.move_to_pose('left_arm', left_pose)\r\n        right_success = await self.arm.move_to_pose('right_arm', right_pose)\r\n\r\n        return left_success and right_success\r\n\r\n    async def carry_large_object(\r\n        self,\r\n        object_pose: Pose,\r\n        target_pose: Pose,\r\n        object_width: float\r\n    ) -> bool:\r\n        \"\"\"Carry large object with both hands.\"\"\"\r\n        self.get_logger().info('Bimanual carry operation')\r\n\r\n        # Calculate grasp positions on either side of object\r\n        half_width = object_width / 2 + 0.05  # Grasp margin\r\n\r\n        left_grasp = Pose()\r\n        left_grasp.position.x = object_pose.position.x\r\n        left_grasp.position.y = object_pose.position.y + half_width\r\n        left_grasp.position.z = object_pose.position.z\r\n        # Inward-facing orientation\r\n        left_grasp.orientation.x = 0.0\r\n        left_grasp.orientation.y = 0.707\r\n        left_grasp.orientation.z = 0.0\r\n        left_grasp.orientation.w = 0.707\r\n\r\n        right_grasp = Pose()\r\n        right_grasp.position.x = object_pose.position.x\r\n        right_grasp.position.y = object_pose.position.y - half_width\r\n        right_grasp.position.z = object_pose.position.z\r\n        right_grasp.orientation.x = 0.0\r\n        right_grasp.orientation.y = 0.707\r\n        right_grasp.orientation.z = 0.0\r\n        right_grasp.orientation.w = -0.707\r\n\r\n        # Open both grippers\r\n        self.arm.open_gripper('left')\r\n        self.arm.open_gripper('right')\r\n\r\n        # Move to grasp positions\r\n        success = await self.synchronized_move(left_grasp, right_grasp)\r\n        if not success:\r\n            return False\r\n\r\n        # Close grippers\r\n        self.arm.close_gripper('left')\r\n        self.arm.close_gripper('right')\r\n        await asyncio.sleep(0.5)\r\n\r\n        # Lift and carry to target\r\n        left_target = Pose()\r\n        left_target.position.x = target_pose.position.x\r\n        left_target.position.y = target_pose.position.y + half_width\r\n        left_target.position.z = target_pose.position.z\r\n        left_target.orientation = left_grasp.orientation\r\n\r\n        right_target = Pose()\r\n        right_target.position.x = target_pose.position.x\r\n        right_target.position.y = target_pose.position.y - half_width\r\n        right_target.position.z = target_pose.position.z\r\n        right_target.orientation = right_grasp.orientation\r\n\r\n        success = await self.synchronized_move(left_target, right_target)\r\n        if not success:\r\n            return False\r\n\r\n        # Release\r\n        self.arm.open_gripper('left')\r\n        self.arm.open_gripper('right')\r\n\r\n        return True\n"})}),"\n",(0,o.jsx)(e.hr,{}),"\n",(0,o.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,o.jsx)(e.p,{children:"This chapter covered manipulation system implementation:"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"MoveIt 2 configuration"})," with SRDF, kinematics, and motion planning parameters."]}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Arm controller"})," providing high-level motion commands and gripper control."]}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Pick and place actions"})," with approach, grasp, lift, and retreat phases."]}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Grasp planning"})," generating candidate poses for different object shapes."]}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Bimanual coordination"})," for handoffs and large object manipulation."]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(e.hr,{}),"\n",(0,o.jsx)(e.h2,{id:"manipulation-checklist",children:"Manipulation Checklist"}),"\n",(0,o.jsx)(e.p,{children:"Before proceeding, verify:"}),"\n",(0,o.jsxs)(e.ul,{className:"contains-task-list",children:["\n",(0,o.jsxs)(e.li,{className:"task-list-item",children:[(0,o.jsx)(e.input,{type:"checkbox",disabled:!0})," ","MoveIt 2 plans paths for both arms"]}),"\n",(0,o.jsxs)(e.li,{className:"task-list-item",children:[(0,o.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Gripper open/close commands work"]}),"\n",(0,o.jsxs)(e.li,{className:"task-list-item",children:[(0,o.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Pick action successfully grasps objects"]}),"\n",(0,o.jsxs)(e.li,{className:"task-list-item",children:[(0,o.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Place action successfully releases objects"]}),"\n",(0,o.jsxs)(e.li,{className:"task-list-item",children:[(0,o.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Grasp planning generates valid poses"]}),"\n",(0,o.jsxs)(e.li,{className:"task-list-item",children:[(0,o.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Arms don't collide with each other or environment"]}),"\n"]}),"\n",(0,o.jsx)(e.hr,{}),"\n",(0,o.jsx)(e.h2,{id:"whats-next",children:"What's Next"}),"\n",(0,o.jsxs)(e.p,{children:["In ",(0,o.jsx)(e.a,{href:"/capstone/chapter-5-integration",children:"Chapter 5: Integration & Testing"}),", you'll bring all systems together for end-to-end VLA-controlled operation."]})]})}function _(r={}){const{wrapper:e}={...(0,a.R)(),...r.components};return e?(0,o.jsx)(e,{...r,children:(0,o.jsx)(c,{...r})}):c(r)}},8453(r,e,n){n.d(e,{R:()=>i,x:()=>s});var t=n(6540);const o={},a=t.createContext(o);function i(r){const e=t.useContext(a);return t.useMemo(function(){return"function"==typeof r?r(e):{...e,...r}},[e,r])}function s(r){let e;return e=r.disableParentContext?"function"==typeof r.components?r.components(o):r.components||o:i(r.components),t.createElement(a.Provider,{value:e},r.children)}}}]);