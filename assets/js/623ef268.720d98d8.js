"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[4177],{4647(e,r,n){n.r(r),n.d(r,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>a,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"module-5/chapter-6-failure-handling","title":"Chapter 6: Failure Handling","description":"Chapter Goal","source":"@site/docs/module-5/chapter-6-failure-handling.md","sourceDirName":"module-5","slug":"/module-5/chapter-6-failure-handling","permalink":"/Master-Robotics-AI/textbook/module-5/chapter-6-failure-handling","draft":false,"unlisted":false,"editUrl":"https://github.com/HasnainCodeHub/Master-Robotics-AI/tree/main/docs/docs/module-5/chapter-6-failure-handling.md","tags":[],"version":"current","sidebarPosition":7,"frontMatter":{"id":"chapter-6-failure-handling","title":"Chapter 6: Failure Handling","sidebar_label":"6. Failure Handling","sidebar_position":7},"sidebar":"textbookSidebar","previous":{"title":"5. Safety Constraints","permalink":"/Master-Robotics-AI/textbook/module-5/chapter-5-safety-constraints"},"next":{"title":"Capstone Overview","permalink":"/Master-Robotics-AI/textbook/capstone/"}}');var s=n(4848),i=n(8453);const a={id:"chapter-6-failure-handling",title:"Chapter 6: Failure Handling",sidebar_label:"6. Failure Handling",sidebar_position:7},o="Chapter 6: Failure Handling and Recovery Strategies",l={},c=[{value:"Chapter Goal",id:"chapter-goal",level:2},{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"VLA Failure Taxonomy",id:"taxonomy",level:2},{value:"Pipeline Stage Failures",id:"pipeline-stage-failures",level:3},{value:"Failure Classification",id:"failure-classification",level:3},{value:"Failure Detection",id:"detection",level:2},{value:"Pipeline Health Monitor",id:"pipeline-health-monitor",level:3},{value:"Stage-Specific Monitors",id:"stage-specific-monitors",level:3},{value:"Recovery Strategies",id:"recovery",level:2},{value:"Recovery Strategy Registry",id:"recovery-strategy-registry",level:3},{value:"Recovery Orchestrator",id:"recovery-orchestrator",level:3},{value:"Human-in-the-Loop Recovery",id:"human-loop",level:2},{value:"Human Interaction Manager",id:"human-interaction-manager",level:3},{value:"Graceful Degradation",id:"degradation",level:2},{value:"Degradation Modes",id:"degradation-modes",level:3},{value:"Fallback Handlers",id:"fallback-handlers",level:3},{value:"Error Logging and Analysis",id:"logging",level:2},{value:"Comprehensive Error Logger",id:"comprehensive-error-logger",level:3},{value:"Analytics Dashboard Data",id:"analytics-dashboard-data",level:3},{value:"Summary",id:"summary",level:2},{value:"Self-Assessment Questions",id:"self-assessment-questions",level:2},{value:"Module 5 Complete",id:"module-5-complete",level:2}];function u(e){const r={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(r.header,{children:(0,s.jsx)(r.h1,{id:"chapter-6-failure-handling-and-recovery-strategies",children:"Chapter 6: Failure Handling and Recovery Strategies"})}),"\n",(0,s.jsx)(r.h2,{id:"chapter-goal",children:"Chapter Goal"}),"\n",(0,s.jsxs)(r.p,{children:["By the end of this chapter, you will be able to ",(0,s.jsx)(r.strong,{children:"implement comprehensive failure detection and recovery strategies for VLA systems"}),", including graceful degradation, human-in-the-loop recovery, and robust error reporting."]}),"\n",(0,s.jsx)(r.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,s.jsx)(r.p,{children:"After completing this chapter, you will be able to:"}),"\n",(0,s.jsxs)(r.table,{children:[(0,s.jsx)(r.thead,{children:(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.th,{children:"ID"}),(0,s.jsx)(r.th,{children:"Objective"})]})}),(0,s.jsxs)(r.tbody,{children:[(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:"6.1"}),(0,s.jsx)(r.td,{children:"Classify failure modes in VLA pipelines"})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:"6.2"}),(0,s.jsx)(r.td,{children:"Implement failure detection at each pipeline stage"})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:"6.3"}),(0,s.jsx)(r.td,{children:"Design recovery strategies for common failures"})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:"6.4"}),(0,s.jsx)(r.td,{children:"Implement human-in-the-loop recovery"})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:"6.5"}),(0,s.jsx)(r.td,{children:"Design graceful degradation modes"})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:"6.6"}),(0,s.jsx)(r.td,{children:"Implement comprehensive error logging and analysis"})]})]})]}),"\n",(0,s.jsx)(r.hr,{}),"\n",(0,s.jsx)(r.h2,{id:"taxonomy",children:"VLA Failure Taxonomy"}),"\n",(0,s.jsx)(r.h3,{id:"pipeline-stage-failures",children:"Pipeline Stage Failures"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502                        VLA FAILURE MODES                            \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502                                                                     \u2502\r\n\u2502  Speech \u2500\u2500\u25ba LLM \u2500\u2500\u25ba Grounding \u2500\u2500\u25ba Safety \u2500\u2500\u25ba Execution \u2500\u2500\u25ba Monitor  \u2502\r\n\u2502    \u2502         \u2502          \u2502           \u2502            \u2502           \u2502      \u2502\r\n\u2502    \u25bc         \u25bc          \u25bc           \u25bc            \u25bc           \u25bc      \u2502\r\n\u2502  - Noise   - Timeout  - Not found - Rejected  - Collision  - Drift  \u2502\r\n\u2502  - Silence - Invalid  - Ambiguous              - Timeout   - Stuck  \u2502\r\n\u2502  - Wrong   - Refusal  - Out of                 - Hardware           \u2502\r\n\u2502    text               reach                     failure             \u2502\r\n\u2502                                                                     \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,s.jsx)(r.h3,{id:"failure-classification",children:"Failure Classification"}),"\n",(0,s.jsxs)(r.table,{children:[(0,s.jsx)(r.thead,{children:(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.th,{children:"Category"}),(0,s.jsx)(r.th,{children:"Examples"}),(0,s.jsx)(r.th,{children:"Severity"}),(0,s.jsx)(r.th,{children:"Recovery"})]})}),(0,s.jsxs)(r.tbody,{children:[(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:"Transient"}),(0,s.jsx)(r.td,{children:"Network timeout, brief occlusion"}),(0,s.jsx)(r.td,{children:"Low"}),(0,s.jsx)(r.td,{children:"Retry"})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:"Recoverable"}),(0,s.jsx)(r.td,{children:"Ambiguous reference, unreachable"}),(0,s.jsx)(r.td,{children:"Medium"}),(0,s.jsx)(r.td,{children:"Clarification"})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:"Blocking"}),(0,s.jsx)(r.td,{children:"Object not found, safety rejection"}),(0,s.jsx)(r.td,{children:"High"}),(0,s.jsx)(r.td,{children:"Human help"})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:"Critical"}),(0,s.jsx)(r.td,{children:"Hardware fault, collision"}),(0,s.jsx)(r.td,{children:"Critical"}),(0,s.jsx)(r.td,{children:"Stop, escalate"})]})]})]}),"\n",(0,s.jsx)(r.hr,{}),"\n",(0,s.jsx)(r.h2,{id:"detection",children:"Failure Detection"}),"\n",(0,s.jsx)(r.h3,{id:"pipeline-health-monitor",children:"Pipeline Health Monitor"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-python",children:'#!/usr/bin/env python3\r\n"""VLA pipeline health monitoring and failure detection."""\r\n\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom std_msgs.msg import String\r\nfrom dataclasses import dataclass, field\r\nfrom typing import Dict, List, Optional, Callable\r\nfrom enum import Enum\r\nimport time\r\nimport json\r\n\r\n\r\nclass FailureType(Enum):\r\n    """Types of failures in VLA pipeline."""\r\n    SPEECH_TIMEOUT = "speech_timeout"\r\n    SPEECH_NOISE = "speech_noise"\r\n    SPEECH_EMPTY = "speech_empty"\r\n    LLM_TIMEOUT = "llm_timeout"\r\n    LLM_INVALID = "llm_invalid"\r\n    LLM_REFUSAL = "llm_refusal"\r\n    GROUNDING_NOT_FOUND = "grounding_not_found"\r\n    GROUNDING_AMBIGUOUS = "grounding_ambiguous"\r\n    GROUNDING_UNREACHABLE = "grounding_unreachable"\r\n    SAFETY_REJECTED = "safety_rejected"\r\n    EXECUTION_TIMEOUT = "execution_timeout"\r\n    EXECUTION_COLLISION = "execution_collision"\r\n    EXECUTION_HARDWARE = "execution_hardware"\r\n    MONITORING_DRIFT = "monitoring_drift"\r\n\r\n\r\n@dataclass\r\nclass Failure:\r\n    """Details of a detected failure."""\r\n    failure_type: FailureType\r\n    stage: str\r\n    message: str\r\n    timestamp: float = field(default_factory=time.time)\r\n    context: Dict = field(default_factory=dict)\r\n    recoverable: bool = True\r\n    retry_count: int = 0\r\n\r\n\r\nclass FailureDetector:\r\n    """Detect failures at each pipeline stage."""\r\n\r\n    def __init__(self):\r\n        self.stage_timeouts = {\r\n            \'speech\': 30.0,    # 30s to speak\r\n            \'llm\': 10.0,       # 10s for LLM response\r\n            \'grounding\': 5.0,  # 5s for grounding\r\n            \'execution\': 60.0, # 60s for action execution\r\n        }\r\n\r\n        self.stage_start_times: Dict[str, float] = {}\r\n        self.pending_failures: List[Failure] = []\r\n\r\n    def start_stage(self, stage: str):\r\n        """Mark stage as started for timeout detection."""\r\n        self.stage_start_times[stage] = time.time()\r\n\r\n    def check_timeout(self, stage: str) -> Optional[Failure]:\r\n        """Check if stage has timed out."""\r\n        if stage not in self.stage_start_times:\r\n            return None\r\n\r\n        elapsed = time.time() - self.stage_start_times[stage]\r\n        timeout = self.stage_timeouts.get(stage, 30.0)\r\n\r\n        if elapsed > timeout:\r\n            return Failure(\r\n                failure_type=FailureType[f"{stage.upper()}_TIMEOUT"],\r\n                stage=stage,\r\n                message=f"{stage} timed out after {elapsed:.1f}s (limit: {timeout}s)",\r\n                context={\'elapsed\': elapsed, \'timeout\': timeout}\r\n            )\r\n\r\n        return None\r\n\r\n    def detect_speech_failure(self, result: dict) -> Optional[Failure]:\r\n        """Detect speech recognition failures."""\r\n        text = result.get(\'text\', \'\').strip()\r\n\r\n        if not text:\r\n            return Failure(\r\n                failure_type=FailureType.SPEECH_EMPTY,\r\n                stage=\'speech\',\r\n                message="No speech detected",\r\n                context=result\r\n            )\r\n\r\n        confidence = result.get(\'confidence\', 1.0)\r\n        if confidence < 0.5:\r\n            return Failure(\r\n                failure_type=FailureType.SPEECH_NOISE,\r\n                stage=\'speech\',\r\n                message=f"Low confidence transcription ({confidence:.2f})",\r\n                context={\'text\': text, \'confidence\': confidence}\r\n            )\r\n\r\n        return None\r\n\r\n    def detect_llm_failure(self, response: dict) -> Optional[Failure]:\r\n        """Detect LLM planning failures."""\r\n        if \'error\' in response:\r\n            return Failure(\r\n                failure_type=FailureType.LLM_INVALID,\r\n                stage=\'llm\',\r\n                message=f"LLM error: {response[\'error\']}",\r\n                context=response\r\n            )\r\n\r\n        if response.get(\'clarification_needed\'):\r\n            return Failure(\r\n                failure_type=FailureType.LLM_REFUSAL,\r\n                stage=\'llm\',\r\n                message=f"LLM needs clarification: {response[\'clarification_needed\']}",\r\n                context=response,\r\n                recoverable=True\r\n            )\r\n\r\n        actions = response.get(\'actions\', [])\r\n        if not actions:\r\n            return Failure(\r\n                failure_type=FailureType.LLM_INVALID,\r\n                stage=\'llm\',\r\n                message="LLM produced no actions",\r\n                context=response\r\n            )\r\n\r\n        return None\r\n\r\n    def detect_grounding_failure(self, result: dict) -> Optional[Failure]:\r\n        """Detect grounding failures."""\r\n        if result.get(\'action\') == \'wait_for_assistance\':\r\n            return Failure(\r\n                failure_type=FailureType.GROUNDING_NOT_FOUND,\r\n                stage=\'grounding\',\r\n                message="Target object not found",\r\n                context=result,\r\n                recoverable=True\r\n            )\r\n\r\n        if result.get(\'action\') == \'wait_for_clarification\':\r\n            return Failure(\r\n                failure_type=FailureType.GROUNDING_AMBIGUOUS,\r\n                stage=\'grounding\',\r\n                message="Ambiguous object reference",\r\n                context=result,\r\n                recoverable=True\r\n            )\r\n\r\n        if result.get(\'action\') == \'navigate_closer\':\r\n            return Failure(\r\n                failure_type=FailureType.GROUNDING_UNREACHABLE,\r\n                stage=\'grounding\',\r\n                message="Target position not reachable from current location",\r\n                context=result,\r\n                recoverable=True\r\n            )\r\n\r\n        return None\n'})}),"\n",(0,s.jsx)(r.h3,{id:"stage-specific-monitors",children:"Stage-Specific Monitors"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-python",children:'class SpeechMonitor:\r\n    """Monitor speech recognition stage."""\r\n\r\n    def __init__(self):\r\n        self.last_speech_time = None\r\n        self.consecutive_failures = 0\r\n        self.noise_level_history = []\r\n\r\n    def on_speech_result(self, result: dict) -> Optional[Failure]:\r\n        """Process speech result and detect failures."""\r\n        self.last_speech_time = time.time()\r\n\r\n        # Check for repeated failures\r\n        if result.get(\'confidence\', 1.0) < 0.3:\r\n            self.consecutive_failures += 1\r\n            if self.consecutive_failures >= 3:\r\n                return Failure(\r\n                    failure_type=FailureType.SPEECH_NOISE,\r\n                    stage=\'speech\',\r\n                    message="Repeated low-confidence transcriptions - "\r\n                            "possible microphone or noise issue",\r\n                    context={\r\n                        \'consecutive_failures\': self.consecutive_failures\r\n                    }\r\n                )\r\n        else:\r\n            self.consecutive_failures = 0\r\n\r\n        return None\r\n\r\n\r\nclass ExecutionMonitor:\r\n    """Monitor action execution stage."""\r\n\r\n    def __init__(self):\r\n        self.action_start_time = None\r\n        self.expected_duration = None\r\n        self.position_history = []\r\n\r\n    def on_action_start(self, action: dict, expected_duration: float):\r\n        """Record action start."""\r\n        self.action_start_time = time.time()\r\n        self.expected_duration = expected_duration\r\n        self.position_history = []\r\n\r\n    def on_position_update(self, position: list):\r\n        """Track position for stuck detection."""\r\n        self.position_history.append({\r\n            \'position\': position,\r\n            \'time\': time.time()\r\n        })\r\n\r\n        # Keep only recent history\r\n        cutoff = time.time() - 5.0\r\n        self.position_history = [\r\n            p for p in self.position_history\r\n            if p[\'time\'] > cutoff\r\n        ]\r\n\r\n    def check_stuck(self) -> Optional[Failure]:\r\n        """Detect if robot is stuck."""\r\n        if len(self.position_history) < 10:\r\n            return None\r\n\r\n        # Check if position hasn\'t changed\r\n        positions = [p[\'position\'] for p in self.position_history]\r\n        pos_array = np.array(positions)\r\n\r\n        movement = np.max(pos_array, axis=0) - np.min(pos_array, axis=0)\r\n        max_movement = np.max(movement)\r\n\r\n        if max_movement < 0.001:  # Less than 1mm movement in 5 seconds\r\n            return Failure(\r\n                failure_type=FailureType.MONITORING_DRIFT,\r\n                stage=\'execution\',\r\n                message="Robot appears stuck - no movement detected",\r\n                context={\r\n                    \'max_movement\': max_movement,\r\n                    \'duration\': 5.0\r\n                }\r\n            )\r\n\r\n        return None\n'})}),"\n",(0,s.jsx)(r.hr,{}),"\n",(0,s.jsx)(r.h2,{id:"recovery",children:"Recovery Strategies"}),"\n",(0,s.jsx)(r.h3,{id:"recovery-strategy-registry",children:"Recovery Strategy Registry"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-python",children:'class RecoveryStrategy:\r\n    """Base class for recovery strategies."""\r\n\r\n    @property\r\n    def applicable_failures(self) -> List[FailureType]:\r\n        """Which failure types this strategy handles."""\r\n        raise NotImplementedError\r\n\r\n    def can_recover(self, failure: Failure, context: dict) -> bool:\r\n        """Check if recovery is possible."""\r\n        return (\r\n            failure.failure_type in self.applicable_failures and\r\n            failure.retry_count < 3\r\n        )\r\n\r\n    def recover(self, failure: Failure, context: dict) -> dict:\r\n        """\r\n        Attempt recovery.\r\n\r\n        Returns:\r\n            Recovery action dict or None if unrecoverable\r\n        """\r\n        raise NotImplementedError\r\n\r\n\r\nclass RetryStrategy(RecoveryStrategy):\r\n    """Simple retry for transient failures."""\r\n\r\n    @property\r\n    def applicable_failures(self) -> List[FailureType]:\r\n        return [\r\n            FailureType.SPEECH_TIMEOUT,\r\n            FailureType.LLM_TIMEOUT,\r\n            FailureType.EXECUTION_TIMEOUT,\r\n        ]\r\n\r\n    def recover(self, failure: Failure, context: dict) -> dict:\r\n        failure.retry_count += 1\r\n        return {\r\n            \'action\': \'retry\',\r\n            \'stage\': failure.stage,\r\n            \'delay\': 1.0 * failure.retry_count,  # Backoff\r\n            \'message\': f"Retrying {failure.stage} (attempt {failure.retry_count})"\r\n        }\r\n\r\n\r\nclass ClarificationStrategy(RecoveryStrategy):\r\n    """Request clarification from user."""\r\n\r\n    @property\r\n    def applicable_failures(self) -> List[FailureType]:\r\n        return [\r\n            FailureType.GROUNDING_AMBIGUOUS,\r\n            FailureType.LLM_REFUSAL,\r\n            FailureType.SPEECH_NOISE,\r\n        ]\r\n\r\n    def recover(self, failure: Failure, context: dict) -> dict:\r\n        # Generate appropriate question based on failure\r\n        if failure.failure_type == FailureType.GROUNDING_AMBIGUOUS:\r\n            candidates = failure.context.get(\'candidates\', [])\r\n            question = self.format_disambiguation_question(candidates)\r\n        elif failure.failure_type == FailureType.SPEECH_NOISE:\r\n            question = "I didn\'t catch that clearly. Could you repeat your command?"\r\n        else:\r\n            question = "I need more information. Could you clarify what you\'d like me to do?"\r\n\r\n        return {\r\n            \'action\': \'request_clarification\',\r\n            \'question\': question,\r\n            \'timeout\': 30.0,\r\n            \'failure_context\': failure.context\r\n        }\r\n\r\n    def format_disambiguation_question(self, candidates: list) -> str:\r\n        """Format question for ambiguous objects."""\r\n        if not candidates:\r\n            return "Which object do you mean?"\r\n\r\n        descriptions = []\r\n        for i, c in enumerate(candidates, 1):\r\n            desc = f"{i}. {c.get(\'color\', \'\')} {c.get(\'class\', \'object\')}"\r\n            if c.get(\'location\'):\r\n                desc += f" ({c[\'location\']})"\r\n            descriptions.append(desc)\r\n\r\n        return f"I see multiple objects: {\', \'.join(descriptions)}. Which one?"\r\n\r\n\r\nclass NavigateCloserStrategy(RecoveryStrategy):\r\n    """Navigate closer to unreachable target."""\r\n\r\n    @property\r\n    def applicable_failures(self) -> List[FailureType]:\r\n        return [FailureType.GROUNDING_UNREACHABLE]\r\n\r\n    def recover(self, failure: Failure, context: dict) -> dict:\r\n        target_pos = failure.context.get(\'target_position\')\r\n\r\n        if target_pos is None:\r\n            return {\r\n                \'action\': \'request_assistance\',\r\n                \'message\': "I cannot reach that location and don\'t know where to go."\r\n            }\r\n\r\n        # Calculate approach position\r\n        approach_pos = self.calculate_approach_position(\r\n            target_pos,\r\n            context.get(\'robot_position\')\r\n        )\r\n\r\n        return {\r\n            \'action\': \'navigate_to\',\r\n            \'position\': approach_pos,\r\n            \'then_retry\': True,\r\n            \'message\': "Moving closer to reach the target."\r\n        }\r\n\r\n    def calculate_approach_position(\r\n        self,\r\n        target: list,\r\n        current: list\r\n    ) -> list:\r\n        """Calculate position closer to target."""\r\n        target = np.array(target)\r\n        current = np.array(current) if current else np.zeros(3)\r\n\r\n        # Move 80% of the way toward target\r\n        direction = target - current\r\n        approach = current + 0.8 * direction\r\n\r\n        return approach.tolist()\r\n\r\n\r\nclass AssistanceStrategy(RecoveryStrategy):\r\n    """Request human assistance for unrecoverable failures."""\r\n\r\n    @property\r\n    def applicable_failures(self) -> List[FailureType]:\r\n        return [\r\n            FailureType.GROUNDING_NOT_FOUND,\r\n            FailureType.EXECUTION_COLLISION,\r\n            FailureType.EXECUTION_HARDWARE,\r\n        ]\r\n\r\n    def can_recover(self, failure: Failure, context: dict) -> bool:\r\n        # Always escalate hardware failures\r\n        if failure.failure_type == FailureType.EXECUTION_HARDWARE:\r\n            return True\r\n        # Escalate after retries exhausted\r\n        return failure.retry_count >= 2\r\n\r\n    def recover(self, failure: Failure, context: dict) -> dict:\r\n        return {\r\n            \'action\': \'request_assistance\',\r\n            \'message\': self.format_assistance_message(failure),\r\n            \'severity\': \'high\' if failure.failure_type == FailureType.EXECUTION_HARDWARE else \'medium\',\r\n            \'requires_acknowledgment\': True\r\n        }\r\n\r\n    def format_assistance_message(self, failure: Failure) -> str:\r\n        """Format message for human assistance."""\r\n        if failure.failure_type == FailureType.GROUNDING_NOT_FOUND:\r\n            target = failure.context.get(\'target\', \'the object\')\r\n            return f"I cannot find {target}. Can you show me where it is?"\r\n\r\n        if failure.failure_type == FailureType.EXECUTION_COLLISION:\r\n            return "I detected a collision and stopped. Please check if it\'s safe to continue."\r\n\r\n        if failure.failure_type == FailureType.EXECUTION_HARDWARE:\r\n            return "I\'m experiencing a hardware issue and need assistance."\r\n\r\n        return "I need help to continue."\n'})}),"\n",(0,s.jsx)(r.h3,{id:"recovery-orchestrator",children:"Recovery Orchestrator"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-python",children:'class RecoveryOrchestrator:\r\n    """Coordinate recovery across strategies."""\r\n\r\n    def __init__(self):\r\n        self.strategies = [\r\n            RetryStrategy(),\r\n            ClarificationStrategy(),\r\n            NavigateCloserStrategy(),\r\n            AssistanceStrategy(),\r\n        ]\r\n\r\n        self.failure_history: List[Failure] = []\r\n        self.max_history = 100\r\n\r\n    def handle_failure(\r\n        self,\r\n        failure: Failure,\r\n        context: dict\r\n    ) -> dict:\r\n        """Find and execute appropriate recovery."""\r\n        self.failure_history.append(failure)\r\n        if len(self.failure_history) > self.max_history:\r\n            self.failure_history.pop(0)\r\n\r\n        # Find applicable strategy\r\n        for strategy in self.strategies:\r\n            if strategy.can_recover(failure, context):\r\n                recovery = strategy.recover(failure, context)\r\n                recovery[\'strategy\'] = strategy.__class__.__name__\r\n                return recovery\r\n\r\n        # No recovery possible\r\n        return {\r\n            \'action\': \'abort\',\r\n            \'message\': f"Unrecoverable failure: {failure.message}",\r\n            \'failure\': failure\r\n        }\r\n\r\n    def get_failure_statistics(self) -> dict:\r\n        """Get statistics on recent failures."""\r\n        if not self.failure_history:\r\n            return {\'total\': 0}\r\n\r\n        by_type = {}\r\n        for f in self.failure_history:\r\n            type_name = f.failure_type.value\r\n            by_type[type_name] = by_type.get(type_name, 0) + 1\r\n\r\n        return {\r\n            \'total\': len(self.failure_history),\r\n            \'by_type\': by_type,\r\n            \'most_common\': max(by_type, key=by_type.get) if by_type else None\r\n        }\n'})}),"\n",(0,s.jsx)(r.hr,{}),"\n",(0,s.jsx)(r.h2,{id:"human-loop",children:"Human-in-the-Loop Recovery"}),"\n",(0,s.jsx)(r.h3,{id:"human-interaction-manager",children:"Human Interaction Manager"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-python",children:"class HumanInteractionManager(Node):\r\n    \"\"\"Manage human-in-the-loop recovery interactions.\"\"\"\r\n\r\n    def __init__(self):\r\n        super().__init__('human_interaction')\r\n\r\n        # State\r\n        self.pending_requests: Dict[str, dict] = {}\r\n        self.interaction_timeout = 60.0  # seconds\r\n\r\n        # Publishers\r\n        self.speech_pub = self.create_publisher(\r\n            String, '/tts/input', 10\r\n        )\r\n        self.display_pub = self.create_publisher(\r\n            String, '/ui/display', 10\r\n        )\r\n\r\n        # Subscribers\r\n        self.speech_input_sub = self.create_subscription(\r\n            String, '/speech/text', self.speech_response_callback, 10\r\n        )\r\n        self.button_sub = self.create_subscription(\r\n            String, '/ui/button', self.button_callback, 10\r\n        )\r\n\r\n        # Response callback\r\n        self.response_callbacks: Dict[str, Callable] = {}\r\n\r\n        self.get_logger().info('Human interaction manager ready')\r\n\r\n    def request_clarification(\r\n        self,\r\n        request_id: str,\r\n        question: str,\r\n        options: Optional[List[str]] = None,\r\n        callback: Optional[Callable] = None\r\n    ):\r\n        \"\"\"Request clarification from human.\"\"\"\r\n        self.pending_requests[request_id] = {\r\n            'question': question,\r\n            'options': options,\r\n            'timestamp': time.time(),\r\n            'type': 'clarification'\r\n        }\r\n\r\n        if callback:\r\n            self.response_callbacks[request_id] = callback\r\n\r\n        # Speak question\r\n        self.speak(question)\r\n\r\n        # Display options if available\r\n        if options:\r\n            self.display_options(question, options)\r\n\r\n        # Set timeout\r\n        self.create_timer(\r\n            self.interaction_timeout,\r\n            lambda: self.handle_timeout(request_id)\r\n        )\r\n\r\n    def request_assistance(\r\n        self,\r\n        request_id: str,\r\n        message: str,\r\n        severity: str = 'medium',\r\n        callback: Optional[Callable] = None\r\n    ):\r\n        \"\"\"Request human assistance.\"\"\"\r\n        self.pending_requests[request_id] = {\r\n            'message': message,\r\n            'severity': severity,\r\n            'timestamp': time.time(),\r\n            'type': 'assistance'\r\n        }\r\n\r\n        if callback:\r\n            self.response_callbacks[request_id] = callback\r\n\r\n        # Alert based on severity\r\n        if severity == 'high':\r\n            self.speak(f\"Attention! {message}\")\r\n            self.display_alert(message, 'error')\r\n        else:\r\n            self.speak(message)\r\n            self.display_alert(message, 'warning')\r\n\r\n    def speech_response_callback(self, msg: String):\r\n        \"\"\"Handle speech response from human.\"\"\"\r\n        response_text = msg.data.strip().lower()\r\n\r\n        # Match to pending requests\r\n        for request_id, request in list(self.pending_requests.items()):\r\n            if request['type'] == 'clarification':\r\n                # Try to match response to options\r\n                matched = self.match_response(\r\n                    response_text,\r\n                    request.get('options', [])\r\n                )\r\n\r\n                if matched is not None:\r\n                    self.resolve_request(request_id, matched)\r\n                    return\r\n\r\n        # No match - might be new command\r\n        self.get_logger().info(f'Unmatched speech: {response_text}')\r\n\r\n    def match_response(\r\n        self,\r\n        response: str,\r\n        options: List[str]\r\n    ) -> Optional[str]:\r\n        \"\"\"Match response to available options.\"\"\"\r\n        # Direct match\r\n        for opt in options:\r\n            if opt.lower() in response or response in opt.lower():\r\n                return opt\r\n\r\n        # Number match (\"the first one\", \"number 2\")\r\n        numbers = ['first', 'second', 'third', '1', '2', '3', 'one', 'two', 'three']\r\n        for i, num in enumerate(numbers):\r\n            if num in response and i % 3 < len(options):\r\n                return options[i % 3]\r\n\r\n        return None\r\n\r\n    def resolve_request(self, request_id: str, response: Any):\r\n        \"\"\"Resolve pending request with response.\"\"\"\r\n        if request_id in self.pending_requests:\r\n            del self.pending_requests[request_id]\r\n\r\n        if request_id in self.response_callbacks:\r\n            callback = self.response_callbacks.pop(request_id)\r\n            callback(response)\r\n\r\n    def handle_timeout(self, request_id: str):\r\n        \"\"\"Handle interaction timeout.\"\"\"\r\n        if request_id not in self.pending_requests:\r\n            return  # Already resolved\r\n\r\n        request = self.pending_requests.pop(request_id)\r\n        self.get_logger().warn(f'Interaction timeout: {request_id}')\r\n\r\n        if request_id in self.response_callbacks:\r\n            callback = self.response_callbacks.pop(request_id)\r\n            callback(None)  # Indicate timeout\r\n\r\n    def speak(self, text: str):\r\n        \"\"\"Send text to speech synthesis.\"\"\"\r\n        msg = String()\r\n        msg.data = text\r\n        self.speech_pub.publish(msg)\r\n\r\n    def display_options(self, question: str, options: List[str]):\r\n        \"\"\"Display options on UI.\"\"\"\r\n        display = {\r\n            'type': 'options',\r\n            'question': question,\r\n            'options': options\r\n        }\r\n        msg = String()\r\n        msg.data = json.dumps(display)\r\n        self.display_pub.publish(msg)\r\n\r\n    def display_alert(self, message: str, level: str):\r\n        \"\"\"Display alert on UI.\"\"\"\r\n        alert = {\r\n            'type': 'alert',\r\n            'message': message,\r\n            'level': level\r\n        }\r\n        msg = String()\r\n        msg.data = json.dumps(alert)\r\n        self.display_pub.publish(msg)\n"})}),"\n",(0,s.jsx)(r.hr,{}),"\n",(0,s.jsx)(r.h2,{id:"degradation",children:"Graceful Degradation"}),"\n",(0,s.jsx)(r.h3,{id:"degradation-modes",children:"Degradation Modes"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-python",children:'class DegradationMode(Enum):\r\n    """Operating modes with reduced capability."""\r\n    FULL = "full"                    # All systems operational\r\n    NO_SPEECH = "no_speech"          # Speech unavailable, text only\r\n    NO_VLM = "no_vlm"                # VLM unavailable, detector only\r\n    NO_NAVIGATION = "no_navigation"  # Navigation unavailable, arm only\r\n    SAFETY_ONLY = "safety_only"      # Only safe, simple commands\r\n    MANUAL = "manual"                # Human teleoperation only\r\n\r\n\r\nclass DegradationManager:\r\n    """Manage graceful degradation of VLA capabilities."""\r\n\r\n    def __init__(self):\r\n        self.current_mode = DegradationMode.FULL\r\n        self.component_status = {\r\n            \'speech\': True,\r\n            \'llm\': True,\r\n            \'vlm\': True,\r\n            \'grounding\': True,\r\n            \'navigation\': True,\r\n            \'manipulation\': True,\r\n        }\r\n\r\n        self.mode_capabilities = {\r\n            DegradationMode.FULL: {\'all\'},\r\n            DegradationMode.NO_SPEECH: {\'text_commands\', \'execution\'},\r\n            DegradationMode.NO_VLM: {\'speech\', \'llm\', \'detector_grounding\'},\r\n            DegradationMode.NO_NAVIGATION: {\'speech\', \'llm\', \'manipulation\'},\r\n            DegradationMode.SAFETY_ONLY: {\'simple_commands\'},\r\n            DegradationMode.MANUAL: {\'teleoperation\'},\r\n        }\r\n\r\n    def report_component_failure(self, component: str):\r\n        """Report component failure and adjust mode."""\r\n        self.component_status[component] = False\r\n        self.update_mode()\r\n\r\n    def report_component_recovery(self, component: str):\r\n        """Report component recovery."""\r\n        self.component_status[component] = True\r\n        self.update_mode()\r\n\r\n    def update_mode(self):\r\n        """Update degradation mode based on component status."""\r\n        if all(self.component_status.values()):\r\n            self.current_mode = DegradationMode.FULL\r\n        elif not self.component_status[\'speech\']:\r\n            self.current_mode = DegradationMode.NO_SPEECH\r\n        elif not self.component_status[\'vlm\']:\r\n            self.current_mode = DegradationMode.NO_VLM\r\n        elif not self.component_status[\'navigation\']:\r\n            self.current_mode = DegradationMode.NO_NAVIGATION\r\n        elif not self.component_status[\'llm\']:\r\n            self.current_mode = DegradationMode.SAFETY_ONLY\r\n        else:\r\n            self.current_mode = DegradationMode.MANUAL\r\n\r\n    def can_execute(self, command_type: str) -> bool:\r\n        """Check if command type can be executed in current mode."""\r\n        capabilities = self.mode_capabilities[self.current_mode]\r\n        return \'all\' in capabilities or command_type in capabilities\r\n\r\n    def get_alternative(self, command_type: str) -> Optional[str]:\r\n        """Suggest alternative for unavailable command."""\r\n        alternatives = {\r\n            \'navigate_to\': "Navigation unavailable. I can only manipulate objects within reach.",\r\n            \'vlm_query\': "Scene understanding unavailable. Please specify object by name and color.",\r\n            \'voice_command\': "Voice unavailable. Please type your command.",\r\n        }\r\n        return alternatives.get(command_type)\n'})}),"\n",(0,s.jsx)(r.h3,{id:"fallback-handlers",children:"Fallback Handlers"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-python",children:'class FallbackHandler:\r\n    """Handle operations when primary method fails."""\r\n\r\n    def __init__(self, degradation_manager: DegradationManager):\r\n        self.degradation = degradation_manager\r\n\r\n    def resolve_object(\r\n        self,\r\n        reference: str,\r\n        use_vlm: bool = True\r\n    ) -> Optional[dict]:\r\n        """Resolve object reference with fallbacks."""\r\n        # Try VLM first if available\r\n        if use_vlm and self.degradation.component_status[\'vlm\']:\r\n            result = self.vlm_resolve(reference)\r\n            if result:\r\n                return result\r\n\r\n        # Fall back to detector\r\n        if self.degradation.component_status[\'grounding\']:\r\n            result = self.detector_resolve(reference)\r\n            if result:\r\n                return result\r\n\r\n        # Fall back to known locations\r\n        result = self.known_location_resolve(reference)\r\n        if result:\r\n            return result\r\n\r\n        return None\r\n\r\n    def vlm_resolve(self, reference: str) -> Optional[dict]:\r\n        """Resolve using VLM."""\r\n        # Implementation would call VLM service\r\n        pass\r\n\r\n    def detector_resolve(self, reference: str) -> Optional[dict]:\r\n        """Resolve using object detector."""\r\n        # Implementation would call detector service\r\n        pass\r\n\r\n    def known_location_resolve(self, reference: str) -> Optional[dict]:\r\n        """Resolve using known location database."""\r\n        known_locations = {\r\n            \'home\': [0.5, 0.0, 0.5],\r\n            \'shelf\': [0.8, 0.3, 0.6],\r\n            \'table\': [0.6, 0.0, 0.3],\r\n        }\r\n\r\n        for name, position in known_locations.items():\r\n            if name in reference.lower():\r\n                return {\r\n                    \'method\': \'known_location\',\r\n                    \'position\': position,\r\n                    \'confidence\': 0.9\r\n                }\r\n\r\n        return None\n'})}),"\n",(0,s.jsx)(r.hr,{}),"\n",(0,s.jsx)(r.h2,{id:"logging",children:"Error Logging and Analysis"}),"\n",(0,s.jsx)(r.h3,{id:"comprehensive-error-logger",children:"Comprehensive Error Logger"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-python",children:"class VLAErrorLogger:\r\n    \"\"\"Log errors for analysis and improvement.\"\"\"\r\n\r\n    def __init__(self, log_dir: str = '/var/log/vla'):\r\n        self.log_dir = Path(log_dir)\r\n        self.log_dir.mkdir(parents=True, exist_ok=True)\r\n\r\n        self.session_id = self.generate_session_id()\r\n        self.session_log = []\r\n\r\n    def generate_session_id(self) -> str:\r\n        \"\"\"Generate unique session ID.\"\"\"\r\n        import uuid\r\n        return f\"vla_{datetime.now().strftime('%Y%m%d_%H%M%S')}_{uuid.uuid4().hex[:8]}\"\r\n\r\n    def log_failure(\r\n        self,\r\n        failure: Failure,\r\n        context: dict,\r\n        recovery_action: Optional[dict] = None\r\n    ):\r\n        \"\"\"Log failure with full context.\"\"\"\r\n        entry = {\r\n            'timestamp': datetime.now().isoformat(),\r\n            'session_id': self.session_id,\r\n            'failure': {\r\n                'type': failure.failure_type.value,\r\n                'stage': failure.stage,\r\n                'message': failure.message,\r\n                'recoverable': failure.recoverable,\r\n                'retry_count': failure.retry_count,\r\n                'context': failure.context\r\n            },\r\n            'system_context': {\r\n                'robot_state': context.get('robot_state'),\r\n                'scene_objects': context.get('scene_objects'),\r\n                'recent_commands': context.get('recent_commands', [])[-5:]\r\n            },\r\n            'recovery': recovery_action\r\n        }\r\n\r\n        self.session_log.append(entry)\r\n        self.write_log_entry(entry)\r\n\r\n    def write_log_entry(self, entry: dict):\r\n        \"\"\"Write entry to log file.\"\"\"\r\n        log_file = self.log_dir / f\"{self.session_id}.jsonl\"\r\n        with open(log_file, 'a') as f:\r\n            f.write(json.dumps(entry) + '\\n')\r\n\r\n    def log_success(self, command: str, execution_time: float):\r\n        \"\"\"Log successful command execution.\"\"\"\r\n        entry = {\r\n            'timestamp': datetime.now().isoformat(),\r\n            'session_id': self.session_id,\r\n            'type': 'success',\r\n            'command': command,\r\n            'execution_time': execution_time\r\n        }\r\n        self.session_log.append(entry)\r\n        self.write_log_entry(entry)\r\n\r\n    def get_session_summary(self) -> dict:\r\n        \"\"\"Get summary of current session.\"\"\"\r\n        successes = [e for e in self.session_log if e.get('type') == 'success']\r\n        failures = [e for e in self.session_log if 'failure' in e]\r\n\r\n        return {\r\n            'session_id': self.session_id,\r\n            'total_commands': len(successes) + len(failures),\r\n            'successes': len(successes),\r\n            'failures': len(failures),\r\n            'success_rate': len(successes) / max(1, len(successes) + len(failures)),\r\n            'failure_types': self.count_failure_types(failures),\r\n            'avg_execution_time': np.mean([s['execution_time'] for s in successes]) if successes else 0\r\n        }\r\n\r\n    def count_failure_types(self, failures: list) -> dict:\r\n        \"\"\"Count failures by type.\"\"\"\r\n        counts = {}\r\n        for f in failures:\r\n            ftype = f['failure']['type']\r\n            counts[ftype] = counts.get(ftype, 0) + 1\r\n        return counts\n"})}),"\n",(0,s.jsx)(r.h3,{id:"analytics-dashboard-data",children:"Analytics Dashboard Data"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-python",children:"class VLAAnalytics:\r\n    \"\"\"Analyze VLA system performance over time.\"\"\"\r\n\r\n    def __init__(self, log_dir: str = '/var/log/vla'):\r\n        self.log_dir = Path(log_dir)\r\n\r\n    def load_logs(self, days: int = 7) -> List[dict]:\r\n        \"\"\"Load logs from recent days.\"\"\"\r\n        entries = []\r\n        cutoff = datetime.now() - timedelta(days=days)\r\n\r\n        for log_file in self.log_dir.glob('*.jsonl'):\r\n            with open(log_file) as f:\r\n                for line in f:\r\n                    entry = json.loads(line)\r\n                    entry_time = datetime.fromisoformat(entry['timestamp'])\r\n                    if entry_time > cutoff:\r\n                        entries.append(entry)\r\n\r\n        return entries\r\n\r\n    def compute_metrics(self, entries: List[dict]) -> dict:\r\n        \"\"\"Compute performance metrics.\"\"\"\r\n        successes = [e for e in entries if e.get('type') == 'success']\r\n        failures = [e for e in entries if 'failure' in e]\r\n\r\n        return {\r\n            'period_start': min(e['timestamp'] for e in entries) if entries else None,\r\n            'period_end': max(e['timestamp'] for e in entries) if entries else None,\r\n            'total_interactions': len(entries),\r\n            'success_rate': len(successes) / max(1, len(entries)),\r\n            'mean_time_to_failure': self.compute_mttf(entries),\r\n            'most_common_failures': self.top_failures(failures, 5),\r\n            'recovery_success_rate': self.recovery_rate(failures),\r\n            'hourly_distribution': self.hourly_distribution(entries)\r\n        }\r\n\r\n    def compute_mttf(self, entries: List[dict]) -> float:\r\n        \"\"\"Compute mean time to failure.\"\"\"\r\n        # Time between consecutive failures\r\n        failure_times = sorted([\r\n            datetime.fromisoformat(e['timestamp'])\r\n            for e in entries if 'failure' in e\r\n        ])\r\n\r\n        if len(failure_times) < 2:\r\n            return float('inf')\r\n\r\n        intervals = [\r\n            (failure_times[i+1] - failure_times[i]).total_seconds()\r\n            for i in range(len(failure_times) - 1)\r\n        ]\r\n\r\n        return np.mean(intervals)\r\n\r\n    def top_failures(self, failures: List[dict], n: int) -> List[dict]:\r\n        \"\"\"Get most common failure types.\"\"\"\r\n        counts = {}\r\n        for f in failures:\r\n            ftype = f['failure']['type']\r\n            counts[ftype] = counts.get(ftype, 0) + 1\r\n\r\n        sorted_types = sorted(counts.items(), key=lambda x: -x[1])\r\n        return [{'type': t, 'count': c} for t, c in sorted_types[:n]]\r\n\r\n    def recovery_rate(self, failures: List[dict]) -> float:\r\n        \"\"\"Compute rate of successful recovery.\"\"\"\r\n        recoverable = [f for f in failures if f['failure'].get('recoverable', False)]\r\n        recovered = [f for f in recoverable if f.get('recovery', {}).get('success', False)]\r\n\r\n        return len(recovered) / max(1, len(recoverable))\r\n\r\n    def hourly_distribution(self, entries: List[dict]) -> dict:\r\n        \"\"\"Get distribution of interactions by hour.\"\"\"\r\n        hours = {}\r\n        for e in entries:\r\n            hour = datetime.fromisoformat(e['timestamp']).hour\r\n            hours[hour] = hours.get(hour, 0) + 1\r\n        return hours\n"})}),"\n",(0,s.jsx)(r.hr,{}),"\n",(0,s.jsx)(r.h2,{id:"summary",children:"Summary"}),"\n",(0,s.jsx)(r.p,{children:"This chapter covered failure handling for VLA systems:"}),"\n",(0,s.jsxs)(r.ol,{children:["\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Failure taxonomy"})," classifies failures by stage, severity, and recoverability."]}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Failure detection"})," monitors each pipeline stage for timeouts, invalid outputs, and anomalies."]}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Recovery strategies"})," provide appropriate responses: retry, clarification, navigation, or human assistance."]}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Human-in-the-loop"})," recovery enables disambiguation and assistance through speech and UI."]}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Graceful degradation"})," maintains partial functionality when components fail."]}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Error logging"})," captures comprehensive data for analysis and improvement."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(r.hr,{}),"\n",(0,s.jsx)(r.h2,{id:"self-assessment-questions",children:"Self-Assessment Questions"}),"\n",(0,s.jsxs)(r.ol,{children:["\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Failure Classification"}),': The VLM says "object on the left" but it\'s actually center-left, causing grounding to fail. What failure type is this? How would you recover?']}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Retry vs. Escalate"}),": LLM times out for the third time. Should you retry again or escalate to human? What factors determine this?"]}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Degradation Decision"}),': VLM is unavailable but the user says "pick up the thing next to the keyboard." Can you proceed? How?']}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Human Interaction"}),": The robot asks for clarification but the human doesn't respond for 30 seconds. What should happen?"]}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Log Analysis"}),': Your failure logs show 40% of failures are "grounding_ambiguous." What system improvement would you prioritize?']}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(r.hr,{}),"\n",(0,s.jsx)(r.h2,{id:"module-5-complete",children:"Module 5 Complete"}),"\n",(0,s.jsx)(r.p,{children:"Congratulations! You've completed Module 5: Vision-Language-Action Systems."}),"\n",(0,s.jsx)(r.p,{children:"You can now:"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"Integrate speech recognition for voice commands"}),"\n",(0,s.jsx)(r.li,{children:"Design LLM prompts for structured task planning"}),"\n",(0,s.jsx)(r.li,{children:"Implement grounding to connect symbols to physical actions"}),"\n",(0,s.jsx)(r.li,{children:"Use VLMs for flexible scene understanding"}),"\n",(0,s.jsx)(r.li,{children:"Implement safety constraints that override AI outputs"}),"\n",(0,s.jsx)(r.li,{children:"Handle failures gracefully with recovery and degradation"}),"\n"]}),"\n",(0,s.jsxs)(r.p,{children:["In the ",(0,s.jsx)(r.strong,{children:"Capstone: Integrated Humanoid System"}),", you'll apply all these capabilities to build a complete humanoid robot system that accepts natural language commands and executes them safely in the physical world."]})]})}function d(e={}){const{wrapper:r}={...(0,i.R)(),...e.components};return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(u,{...e})}):u(e)}},8453(e,r,n){n.d(r,{R:()=>a,x:()=>o});var t=n(6540);const s={},i=t.createContext(s);function a(e){const r=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function o(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),t.createElement(i.Provider,{value:r},e.children)}}}]);