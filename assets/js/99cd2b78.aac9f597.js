"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[9657],{7773(e,n,r){r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"module-4/chapter-6-sim-to-real-transfer","title":"Chapter 6: Sim-to-Real Transfer","description":"Chapter Goal","source":"@site/docs/module-4/chapter-6-sim-to-real-transfer.md","sourceDirName":"module-4","slug":"/module-4/chapter-6-sim-to-real-transfer","permalink":"/Master-Robotics-AI/textbook/module-4/chapter-6-sim-to-real-transfer","draft":false,"unlisted":false,"editUrl":"https://github.com/HasnainCodeHub/Master-Robotics-AI/tree/main/docs/docs/module-4/chapter-6-sim-to-real-transfer.md","tags":[],"version":"current","sidebarPosition":7,"frontMatter":{"id":"chapter-6-sim-to-real-transfer","title":"Chapter 6: Sim-to-Real Transfer","sidebar_label":"6. Sim-to-Real Transfer","sidebar_position":7},"sidebar":"textbookSidebar","previous":{"title":"5. Domain Randomization","permalink":"/Master-Robotics-AI/textbook/module-4/chapter-5-domain-randomization"},"next":{"title":"Module 5 Overview","permalink":"/Master-Robotics-AI/textbook/module-5/"}}');var t=r(4848),s=r(8453);const a={id:"chapter-6-sim-to-real-transfer",title:"Chapter 6: Sim-to-Real Transfer",sidebar_label:"6. Sim-to-Real Transfer",sidebar_position:7},o="Chapter 6: Sim-to-Real Transfer Strategies",l={},d=[{value:"Chapter Goal",id:"chapter-goal",level:2},{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Transfer Approach Taxonomy",id:"taxonomy",level:2},{value:"Comparison",id:"comparison",level:3},{value:"Combined Strategy",id:"combined-strategy",level:3},{value:"System Identification",id:"system-id",level:2},{value:"What to Identify",id:"what-to-identify",level:3},{value:"Motor System Identification",id:"motor-system-identification",level:3},{value:"Updating Isaac Sim with Identified Parameters",id:"updating-isaac-sim-with-identified-parameters",level:3},{value:"Validation Experiment Design",id:"validation",level:2},{value:"Experiment Template",id:"experiment-template",level:3},{value:"Validation Script",id:"validation-script",level:3},{value:"Performance Prediction",id:"prediction",level:2},{value:"Uncertainty Quantification",id:"uncertainty-quantification",level:3},{value:"Transfer Factor Estimation",id:"transfer-factor-estimation",level:3},{value:"Prediction Model",id:"prediction-model",level:3},{value:"Production Pipeline Design",id:"pipeline",level:2},{value:"CI/CD for Robotics",id:"cicd-for-robotics",level:3},{value:"Pipeline Configuration",id:"pipeline-configuration",level:3},{value:"Case Studies",id:"case-studies",level:2},{value:"Case 1: Warehouse Navigation",id:"case-1-warehouse-navigation",level:3},{value:"Case 2: Pick-and-Place",id:"case-2-pick-and-place",level:3},{value:"Case 3: Visual SLAM",id:"case-3-visual-slam",level:3},{value:"Capstone Preparation",id:"capstone",level:2},{value:"Simulation Environment",id:"simulation-environment",level:3},{value:"Perception Pipeline",id:"perception-pipeline",level:3},{value:"Transfer Methodology",id:"transfer-methodology",level:3},{value:"What&#39;s Next in Module 5",id:"whats-next-in-module-5",level:3},{value:"Summary",id:"summary",level:2},{value:"Module 4 Complete",id:"module-4-complete",level:2},{value:"What&#39;s Next",id:"whats-next",level:2}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"chapter-6-sim-to-real-transfer-strategies",children:"Chapter 6: Sim-to-Real Transfer Strategies"})}),"\n",(0,t.jsx)(n.h2,{id:"chapter-goal",children:"Chapter Goal"}),"\n",(0,t.jsxs)(n.p,{children:["By the end of this chapter, you will be able to ",(0,t.jsx)(n.strong,{children:"synthesize all Module 4 capabilities into comprehensive sim-to-real transfer strategies"}),", preparing for capstone integration and eventual hardware deployment."]}),"\n",(0,t.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,t.jsx)(n.p,{children:"After completing this chapter, you will be able to:"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"ID"}),(0,t.jsx)(n.th,{children:"Objective"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"6.1"}),(0,t.jsx)(n.td,{children:"Categorize sim-to-real transfer approaches and their tradeoffs"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"6.2"}),(0,t.jsx)(n.td,{children:"Design sim-to-real validation experiments with metrics"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"6.3"}),(0,t.jsx)(n.td,{children:"Implement system identification to improve simulation"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"6.4"}),(0,t.jsx)(n.td,{children:"Articulate realistic transfer expectations with quantified uncertainty"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"6.5"}),(0,t.jsx)(n.td,{children:"Design complete sim-to-real pipelines"})]})]})]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"taxonomy",children:"Transfer Approach Taxonomy"}),"\n",(0,t.jsx)(n.p,{children:"Three main strategies for bridging the sim-to-real gap:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502               Sim-to-Real Transfer Approaches                    \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502                                                                  \u2502\r\n\u2502  1. DOMAIN RANDOMIZATION                                        \u2502\r\n\u2502     \u2514\u2500\u2500 Train on varied simulation, hope real is covered        \u2502\r\n\u2502         Pro: No real data needed                                \u2502\r\n\u2502         Con: May require extreme variation                      \u2502\r\n\u2502                                                                  \u2502\r\n\u2502  2. SYSTEM IDENTIFICATION                                       \u2502\r\n\u2502     \u2514\u2500\u2500 Measure real system, make simulation match              \u2502\r\n\u2502         Pro: High fidelity for specific system                  \u2502\r\n\u2502         Con: Requires hardware access                           \u2502\r\n\u2502                                                                  \u2502\r\n\u2502  3. DOMAIN ADAPTATION                                           \u2502\r\n\u2502     \u2514\u2500\u2500 Use real data to adjust trained models                  \u2502\r\n\u2502         Pro: Directly addresses real distribution               \u2502\r\n\u2502         Con: Needs real data collection                         \u2502\r\n\u2502                                                                  \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,t.jsx)(n.h3,{id:"comparison",children:"Comparison"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Approach"}),(0,t.jsx)(n.th,{children:"Real Data"}),(0,t.jsx)(n.th,{children:"Hardware"}),(0,t.jsx)(n.th,{children:"Compute"}),(0,t.jsx)(n.th,{children:"Best For"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Randomization"}),(0,t.jsx)(n.td,{children:"None"}),(0,t.jsx)(n.td,{children:"None"}),(0,t.jsx)(n.td,{children:"High"}),(0,t.jsx)(n.td,{children:"Perception"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"System ID"}),(0,t.jsx)(n.td,{children:"Limited"}),(0,t.jsx)(n.td,{children:"Required"}),(0,t.jsx)(n.td,{children:"Low"}),(0,t.jsx)(n.td,{children:"Control"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Adaptation"}),(0,t.jsx)(n.td,{children:"Substantial"}),(0,t.jsx)(n.td,{children:"Required"}),(0,t.jsx)(n.td,{children:"Moderate"}),(0,t.jsx)(n.td,{children:"Fine-tuning"})]})]})]}),"\n",(0,t.jsx)(n.h3,{id:"combined-strategy",children:"Combined Strategy"}),"\n",(0,t.jsx)(n.p,{children:"Most successful transfers combine approaches:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"1. Randomization (pre-deployment)\r\n   \u2514\u2500\u2500 Train robust base model\r\n\r\n2. System Identification (at deployment)\r\n   \u2514\u2500\u2500 Calibrate simulation to specific robot\r\n\r\n3. Adaptation (during deployment)\r\n   \u2514\u2500\u2500 Fine-tune with real experience\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"system-id",children:"System Identification"}),"\n",(0,t.jsx)(n.h3,{id:"what-to-identify",children:"What to Identify"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Parameter"}),(0,t.jsx)(n.th,{children:"Measurement Method"}),(0,t.jsx)(n.th,{children:"Equipment"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Mass"}),(0,t.jsx)(n.td,{children:"Scale"}),(0,t.jsx)(n.td,{children:"Digital scale"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Inertia"}),(0,t.jsx)(n.td,{children:"Pendulum test"}),(0,t.jsx)(n.td,{children:"Swing fixture"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Motor time constant"}),(0,t.jsx)(n.td,{children:"Step response"}),(0,t.jsx)(n.td,{children:"Encoder + command log"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Friction"}),(0,t.jsx)(n.td,{children:"Coastdown test"}),(0,t.jsx)(n.td,{children:"Encoder only"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Camera intrinsics"}),(0,t.jsx)(n.td,{children:"Calibration board"}),(0,t.jsx)(n.td,{children:"Checkerboard"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"LiDAR alignment"}),(0,t.jsx)(n.td,{children:"Point cloud registration"}),(0,t.jsx)(n.td,{children:"Known targets"})]})]})]}),"\n",(0,t.jsx)(n.h3,{id:"motor-system-identification",children:"Motor System Identification"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'#!/usr/bin/env python3\r\n"""\r\nMotor System Identification\r\n\r\nMeasure step response to estimate time constant and gain.\r\n"""\r\n\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nimport numpy as np\r\nimport matplotlib.pyplot as plt\r\n\r\n\r\nclass MotorSysID(Node):\r\n    def __init__(self):\r\n        super().__init__(\'motor_sysid\')\r\n\r\n        self.command_value = 0.0\r\n        self.velocities = []\r\n        self.timestamps = []\r\n        self.recording = False\r\n\r\n        # Publishers/Subscribers\r\n        self.cmd_pub = self.create_publisher(...)\r\n        self.state_sub = self.create_subscription(...)\r\n\r\n    def run_step_test(self, target_velocity: float, duration: float):\r\n        """Apply step command and record response."""\r\n        self.command_value = target_velocity\r\n        self.recording = True\r\n        self.velocities = []\r\n        self.timestamps = []\r\n\r\n        # Wait for duration\r\n        # ... recording happens in callback\r\n\r\n        self.recording = False\r\n        return self.analyze_response(target_velocity)\r\n\r\n    def analyze_response(self, commanded: float):\r\n        """Fit first-order model to response."""\r\n        t = np.array(self.timestamps)\r\n        v = np.array(self.velocities)\r\n\r\n        # Normalize\r\n        t = t - t[0]\r\n        v_norm = v / commanded\r\n\r\n        # Find time constant (time to reach 63.2%)\r\n        idx_63 = np.argmax(v_norm >= 0.632)\r\n        tau = t[idx_63]\r\n\r\n        # Steady-state gain\r\n        K = np.mean(v[-10:]) / commanded\r\n\r\n        return {\r\n            \'time_constant\': tau,\r\n            \'gain\': K,\r\n            \'model\': f\'G(s) = {K:.3f} / ({tau:.4f}s + 1)\'\r\n        }\n'})}),"\n",(0,t.jsx)(n.h3,{id:"updating-isaac-sim-with-identified-parameters",children:"Updating Isaac Sim with Identified Parameters"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"# After system identification, update Isaac Sim config\r\n\r\nidentified_params = {\r\n    'motor_time_constant': 0.05,  # From sysid\r\n    'motor_gain': 0.98,\r\n    'wheel_friction': 0.85,\r\n    'floor_friction': 0.72,\r\n}\r\n\r\n# Apply to Isaac Sim\r\nfrom omni.isaac.core.utils.physics import set_rigid_body_properties\r\n\r\nrobot = world.scene.get_object(\"my_robot\")\r\n\r\n# Update motor dynamics\r\nfor joint in robot.articulation_controller.joints:\r\n    joint.set_drive_params(\r\n        stiffness=100,\r\n        damping=identified_params['motor_time_constant'] * 100,\r\n    )\r\n\r\n# Update friction\r\nfloor = world.scene.get_object(\"floor\")\r\nset_rigid_body_properties(\r\n    floor.prim_path,\r\n    static_friction=identified_params['floor_friction'],\r\n    dynamic_friction=identified_params['floor_friction'] * 0.9\r\n)\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"validation",children:"Validation Experiment Design"}),"\n",(0,t.jsx)(n.h3,{id:"experiment-template",children:"Experiment Template"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502             Sim-to-Real Validation Experiment                    \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502                                                                  \u2502\r\n\u2502  1. HYPOTHESIS                                                   \u2502\r\n\u2502     "Navigation policy trained in simulation will achieve       \u2502\r\n\u2502      \u226580% success rate on hardware"                             \u2502\r\n\u2502                                                                  \u2502\r\n\u2502  2. METRICS                                                      \u2502\r\n\u2502     - Success rate (reach goal within tolerance)                \u2502\r\n\u2502     - Path efficiency (actual vs optimal length)                \u2502\r\n\u2502     - Collision rate                                            \u2502\r\n\u2502     - Mean time to goal                                         \u2502\r\n\u2502                                                                  \u2502\r\n\u2502  3. SIMULATION TRIALS (N=100)                                   \u2502\r\n\u2502     - Same start/goal positions                                 \u2502\r\n\u2502     - Domain randomization OFF (fair comparison)                \u2502\r\n\u2502     - Record all metrics                                        \u2502\r\n\u2502                                                                  \u2502\r\n\u2502  4. HARDWARE TRIALS (N=50)                                      \u2502\r\n\u2502     - Same start/goal positions as sim                          \u2502\r\n\u2502     - Controlled environment (match sim environment)            \u2502\r\n\u2502     - Record all metrics                                        \u2502\r\n\u2502                                                                  \u2502\r\n\u2502  5. ANALYSIS                                                     \u2502\r\n\u2502     - Compare metric distributions                              \u2502\r\n\u2502     - Identify failure modes                                    \u2502\r\n\u2502     - Map failures to gap categories                            \u2502\r\n\u2502                                                                  \u2502\r\n\u2502  6. ITERATE                                                      \u2502\r\n\u2502     - Address top failure mode                                  \u2502\r\n\u2502     - Repeat validation                                         \u2502\r\n\u2502                                                                  \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n'})}),"\n",(0,t.jsx)(n.h3,{id:"validation-script",children:"Validation Script"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'#!/usr/bin/env python3\r\n"""\r\nSim-to-Real Validation Experiment\r\n\r\nRun controlled trials in simulation for comparison with hardware.\r\n"""\r\n\r\nimport json\r\nfrom dataclasses import dataclass\r\nfrom typing import List\r\nimport numpy as np\r\n\r\n\r\n@dataclass\r\nclass TrialResult:\r\n    trial_id: int\r\n    success: bool\r\n    time_to_goal: float\r\n    path_length: float\r\n    collision_count: int\r\n    failure_mode: str = ""\r\n\r\n\r\nclass ValidationExperiment:\r\n    def __init__(self, name: str, goals: List[tuple]):\r\n        self.name = name\r\n        self.goals = goals\r\n        self.results = []\r\n\r\n    def run_trial(self, trial_id: int, goal: tuple) -> TrialResult:\r\n        """Run single trial - implement for your system."""\r\n        # Send goal to navigation\r\n        # Wait for completion or timeout\r\n        # Record metrics\r\n        pass\r\n\r\n    def run_all_trials(self) -> dict:\r\n        """Run all validation trials."""\r\n        for i, goal in enumerate(self.goals):\r\n            result = self.run_trial(i, goal)\r\n            self.results.append(result)\r\n\r\n        return self.compute_statistics()\r\n\r\n    def compute_statistics(self) -> dict:\r\n        """Compute validation metrics."""\r\n        successes = [r for r in self.results if r.success]\r\n\r\n        stats = {\r\n            \'total_trials\': len(self.results),\r\n            \'success_rate\': len(successes) / len(self.results),\r\n            \'mean_time\': np.mean([r.time_to_goal for r in successes]),\r\n            \'mean_path_length\': np.mean([r.path_length for r in successes]),\r\n            \'collision_rate\': np.mean([r.collision_count > 0 for r in self.results]),\r\n            \'failure_modes\': self.analyze_failures(),\r\n        }\r\n\r\n        return stats\r\n\r\n    def analyze_failures(self) -> dict:\r\n        """Categorize failure modes."""\r\n        failures = [r for r in self.results if not r.success]\r\n        modes = {}\r\n        for f in failures:\r\n            mode = f.failure_mode or "unknown"\r\n            modes[mode] = modes.get(mode, 0) + 1\r\n        return modes\r\n\r\n    def save_results(self, filepath: str):\r\n        """Save results for comparison."""\r\n        data = {\r\n            \'experiment\': self.name,\r\n            \'statistics\': self.compute_statistics(),\r\n            \'raw_results\': [vars(r) for r in self.results]\r\n        }\r\n        with open(filepath, \'w\') as f:\r\n            json.dump(data, f, indent=2)\n'})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"prediction",children:"Performance Prediction"}),"\n",(0,t.jsx)(n.h3,{id:"uncertainty-quantification",children:"Uncertainty Quantification"}),"\n",(0,t.jsx)(n.p,{children:"Simulation results don't directly predict hardware performance:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"Simulation Result \u2192 Transfer Factor \u2192 Hardware Prediction\r\n     90% success     \xd7 0.7-0.9         = 63-81% expected\n"})}),"\n",(0,t.jsx)(n.h3,{id:"transfer-factor-estimation",children:"Transfer Factor Estimation"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Task Type"}),(0,t.jsx)(n.th,{children:"Typical Transfer"}),(0,t.jsx)(n.th,{children:"Factors"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Navigation"}),(0,t.jsx)(n.td,{children:"0.7-0.9"}),(0,t.jsx)(n.td,{children:"LiDAR transfers well"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Perception"}),(0,t.jsx)(n.td,{children:"0.5-0.8"}),(0,t.jsx)(n.td,{children:"Visual domain shift"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Manipulation"}),(0,t.jsx)(n.td,{children:"0.3-0.6"}),(0,t.jsx)(n.td,{children:"Contact physics gap"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Locomotion"}),(0,t.jsx)(n.td,{children:"0.4-0.7"}),(0,t.jsx)(n.td,{children:"Ground interaction"})]})]})]}),"\n",(0,t.jsx)(n.h3,{id:"prediction-model",children:"Prediction Model"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"def predict_hardware_performance(\r\n    sim_success_rate: float,\r\n    task_type: str,\r\n    randomization_used: bool,\r\n    system_id_done: bool\r\n) -> tuple:\r\n    \"\"\"\r\n    Predict hardware performance with uncertainty bounds.\r\n\r\n    Returns:\r\n        (lower_bound, expected, upper_bound)\r\n    \"\"\"\r\n    # Base transfer factors by task\r\n    base_factors = {\r\n        'navigation': (0.7, 0.85),\r\n        'perception': (0.5, 0.75),\r\n        'manipulation': (0.3, 0.55),\r\n        'locomotion': (0.4, 0.65),\r\n    }\r\n\r\n    low, high = base_factors.get(task_type, (0.5, 0.7))\r\n\r\n    # Randomization bonus\r\n    if randomization_used:\r\n        low += 0.05\r\n        high += 0.05\r\n\r\n    # System ID bonus\r\n    if system_id_done:\r\n        low += 0.1\r\n        high += 0.05\r\n\r\n    # Cap at 1.0\r\n    low = min(low, 1.0)\r\n    high = min(high, 1.0)\r\n\r\n    expected = (low + high) / 2\r\n\r\n    return (\r\n        sim_success_rate * low,\r\n        sim_success_rate * expected,\r\n        sim_success_rate * high\r\n    )\r\n\r\n# Example usage\r\nsim_rate = 0.92  # 92% in simulation\r\nlow, expected, high = predict_hardware_performance(\r\n    sim_rate,\r\n    task_type='navigation',\r\n    randomization_used=True,\r\n    system_id_done=True\r\n)\r\nprint(f\"Hardware prediction: {low:.0%} - {expected:.0%} - {high:.0%}\")\r\n# Output: Hardware prediction: 78% - 83% - 88%\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"pipeline",children:"Production Pipeline Design"}),"\n",(0,t.jsx)(n.h3,{id:"cicd-for-robotics",children:"CI/CD for Robotics"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502               Sim-to-Real Production Pipeline                    \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502                                                                  \u2502\r\n\u2502  1. CODE CHANGE                                                  \u2502\r\n\u2502     \u2514\u2500\u2500 Developer commits to main branch                        \u2502\r\n\u2502                                                                  \u2502\r\n\u2502  2. SIMULATION TESTS (Automated)                                \u2502\r\n\u2502     \u2514\u2500\u2500 Unit tests \u2192 Integration tests \u2192 Sim validation         \u2502\r\n\u2502         - Must pass before merge                                \u2502\r\n\u2502                                                                  \u2502\r\n\u2502  3. SYNTHETIC DATA (If perception changed)                      \u2502\r\n\u2502     \u2514\u2500\u2500 Generate new dataset with domain randomization          \u2502\r\n\u2502         - Retrain perception models                             \u2502\r\n\u2502                                                                  \u2502\r\n\u2502  4. SIM VALIDATION (Nightly)                                    \u2502\r\n\u2502     \u2514\u2500\u2500 Full validation suite in Isaac Sim                      \u2502\r\n\u2502         - Track success rate over time                          \u2502\r\n\u2502         - Alert on regression                                   \u2502\r\n\u2502                                                                  \u2502\r\n\u2502  5. HARDWARE STAGING (Weekly)                                   \u2502\r\n\u2502     \u2514\u2500\u2500 Deploy to staging robot                                 \u2502\r\n\u2502         - Run abbreviated validation                            \u2502\r\n\u2502         - Collect real-world data                               \u2502\r\n\u2502                                                                  \u2502\r\n\u2502  6. PRODUCTION DEPLOY (On approval)                             \u2502\r\n\u2502     \u2514\u2500\u2500 Deploy to production fleet                              \u2502\r\n\u2502         - A/B testing if possible                               \u2502\r\n\u2502         - Monitoring and rollback capability                    \u2502\r\n\u2502                                                                  \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,t.jsx)(n.h3,{id:"pipeline-configuration",children:"Pipeline Configuration"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"# .github/workflows/sim-to-real.yml\r\nname: Sim-to-Real Pipeline\r\n\r\non:\r\n  push:\r\n    branches: [main]\r\n  schedule:\r\n    - cron: '0 2 * * *'  # Nightly\r\n\r\njobs:\r\n  unit-tests:\r\n    runs-on: ubuntu-latest\r\n    steps:\r\n      - uses: actions/checkout@v3\r\n      - name: Run unit tests\r\n        run: pytest tests/unit/\r\n\r\n  sim-integration:\r\n    needs: unit-tests\r\n    runs-on: [self-hosted, gpu]  # Requires GPU runner\r\n    steps:\r\n      - uses: actions/checkout@v3\r\n      - name: Launch Isaac Sim headless\r\n        run: ./scripts/launch_isaac_headless.sh\r\n      - name: Run integration tests\r\n        run: pytest tests/integration/\r\n      - name: Run sim validation\r\n        run: python validation/run_sim_validation.py\r\n      - name: Upload results\r\n        uses: actions/upload-artifact@v3\r\n        with:\r\n          name: sim-results\r\n          path: results/\r\n\r\n  synthetic-data:\r\n    needs: sim-integration\r\n    if: contains(github.event.head_commit.modified, 'perception/')\r\n    runs-on: [self-hosted, gpu]\r\n    steps:\r\n      - name: Generate synthetic dataset\r\n        run: python data/generate_synthetic.py --frames 10000\r\n      - name: Train perception model\r\n        run: python perception/train.py\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"case-studies",children:"Case Studies"}),"\n",(0,t.jsx)(n.h3,{id:"case-1-warehouse-navigation",children:"Case 1: Warehouse Navigation"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Task"}),": Mobile robot navigating shelved aisles"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Transfer Result"}),": 85% simulation \u2192 78% hardware"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Gap Analysis"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"LiDAR performed well (same physics)"}),"\n",(0,t.jsx)(n.li,{children:"Occasional localization drift (visual variation)"}),"\n",(0,t.jsx)(n.li,{children:"Few collision issues (conservative planning)"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Lesson"}),": Navigation transfers well with good LiDAR simulation."]}),"\n",(0,t.jsx)(n.h3,{id:"case-2-pick-and-place",children:"Case 2: Pick-and-Place"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Task"}),": Arm picking objects from bins"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Transfer Result"}),": 75% simulation \u2192 42% hardware"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Gap Analysis"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Object detection worked (randomization helped)"}),"\n",(0,t.jsx)(n.li,{children:"Grasp success low (contact physics gap)"}),"\n",(0,t.jsx)(n.li,{children:"Object slip common (friction mismatch)"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Lesson"}),": Manipulation requires extensive system ID or real-world fine-tuning."]}),"\n",(0,t.jsx)(n.h3,{id:"case-3-visual-slam",children:"Case 3: Visual SLAM"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Task"}),": Camera-based localization in office"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Transfer Result"}),": 92% simulation \u2192 71% hardware"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Gap Analysis"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Feature detection worked"}),"\n",(0,t.jsx)(n.li,{children:"Lighting variation caused failures"}),"\n",(0,t.jsx)(n.li,{children:"Dynamic objects (people) not in simulation"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Lesson"}),": VSLAM needs visual randomization AND dynamic object handling."]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"capstone",children:"Capstone Preparation"}),"\n",(0,t.jsx)(n.p,{children:"This module provides the following for your capstone:"}),"\n",(0,t.jsx)(n.h3,{id:"simulation-environment",children:"Simulation Environment"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Isaac Sim warehouse scene"}),"\n",(0,t.jsx)(n.li,{children:"Configured robot with sensors"}),"\n",(0,t.jsx)(n.li,{children:"Domain randomization setup"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"perception-pipeline",children:"Perception Pipeline"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"VSLAM for localization"}),"\n",(0,t.jsx)(n.li,{children:"Object detection for targets"}),"\n",(0,t.jsx)(n.li,{children:"GPU-accelerated processing"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"transfer-methodology",children:"Transfer Methodology"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Validation experiment template"}),"\n",(0,t.jsx)(n.li,{children:"Performance prediction"}),"\n",(0,t.jsx)(n.li,{children:"Failure mode analysis"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"whats-next-in-module-5",children:"What's Next in Module 5"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'Module 4 Foundation          Module 5 Addition\r\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500          \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\r\nIsaac Sim environment   \u2192   VLA model integration\r\nVSLAM localization      \u2192   "Go to X" command processing\r\nObject detection        \u2192   Natural language grounding\r\nTransfer strategies     \u2192   Evaluate language-guided robot\n'})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,t.jsx)(n.p,{children:"This chapter synthesized Module 4 into transfer strategies:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Transfer taxonomy"}),": Randomization (no hardware), system ID (specific hardware), adaptation (with real data)."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"System identification"})," measures real parameters to improve simulation fidelity."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Validation experiments"})," quantify the gap through controlled comparisons."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Performance prediction"})," estimates hardware results with uncertainty bounds."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Production pipelines"})," automate testing from simulation through deployment."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"module-4-complete",children:"Module 4 Complete"}),"\n",(0,t.jsx)(n.p,{children:"Congratulations on completing Module 4: NVIDIA Isaac Ecosystem!"}),"\n",(0,t.jsx)(n.p,{children:"You can now:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Create high-fidelity simulations in Isaac Sim"}),"\n",(0,t.jsx)(n.li,{children:"Implement GPU-accelerated perception with Isaac ROS"}),"\n",(0,t.jsx)(n.li,{children:"Use VSLAM for robust robot localization"}),"\n",(0,t.jsx)(n.li,{children:"Apply domain randomization for transfer robustness"}),"\n",(0,t.jsx)(n.li,{children:"Design and evaluate sim-to-real transfer strategies"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"whats-next",children:"What's Next"}),"\n",(0,t.jsxs)(n.p,{children:["In ",(0,t.jsx)(n.a,{href:"/module-5",children:"Module 5: Vision-Language-Action Systems"}),', you\'ll add natural language understanding to create robots that respond to commands like "pick up the red box" and "navigate to the shelf"\u2014integrating AI with your Isaac-based robotic system.']}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Preview of Module 5 Topics"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Vision-Language Models (VLMs)"}),"\n",(0,t.jsx)(n.li,{children:"Language grounding in perception"}),"\n",(0,t.jsx)(n.li,{children:"VLA architectures for robotics"}),"\n",(0,t.jsx)(n.li,{children:"Natural language to robot action"}),"\n",(0,t.jsx)(n.li,{children:"Capstone integration"}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},8453(e,n,r){r.d(n,{R:()=>a,x:()=>o});var i=r(6540);const t={},s=i.createContext(t);function a(e){const n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);